<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><meta charset=utf-8>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>EXPRESSÕES REGULARES: Editores de texto: Emacs</TITLE>
 <LINK HREF="guia-er-50.html" REL=next>
 <LINK HREF="guia-er-48.html" REL=previous>
 <LINK HREF="guia-er.html#toc6" REL=contents>
</HEAD>
<body bgcolor="white" text=black>
<A HREF="guia-er-50.html">Página seguinte</A>
<A HREF="guia-er-48.html">Página anterior</A>
<A HREF="guia-er.html#toc6">Índice</A>
<HR>
<H2>6.2 Emacs</H2>

<P>
<P>Chamar o emacs de editor de texto é ser superficial, pois editar texto parece ser a coisa menos interessante para fazer neste programa que também lê e-mails, acessa a Internet, faz ftp, entre outros. Mas como nosso interesse aqui é ERs, é isso o que veremos. Contrastando-as com a abundância de funcionalidades, as ERs no emacs são diferentes em alguns aspectos e não têm as chaves!
<P>As ERs são tratadas como <EM>strings</EM>, então valem as dicas já vistas para lidar com isso. Para complicar, ele usa a notação antiga, em que a maioria dos metacaracteres deve ser escapada para serem especiais.
<P>Então juntando esses dois fatos, precisamos fazer <B><CODE>\\[\\(.*\\)\\]</CODE></B> para agrupar o conteúdo de um par de colchetes, o que normalmente seria <B><CODE>\[(.*)\]</CODE></B>.
<P>Há vários comandos que trabalham com ERs, sendo <CODE>re-search-forward</CODE> e <CODE>re-search-backward</CODE> os comandos de busca nas linhas adiante e anteriores, respectivamente. Mas melhores do que estes são os comandos similares que procuram enquanto você digita, já sabendo se sua ER está funcionando ou não antes de finalizá-la: <CODE>isearch-forward-regexp</CODE> e <CODE>isearch-backward-regexp</CODE>.
<P>Como um editor de texto serve para alterar texto, temos o comando <CODE>replace-regexp</CODE> que se encarrega de fazer a substituição de padrões:
<P>
<BLOCKQUOTE><CODE>
<PRE>
M-x replace-regexp &lt;enter&gt; \(Gentalha!\) &lt;enter&gt; \&amp; \1 Prrrr! &lt;enter&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>Com essa seqüência agrupamos a palavra <B><EM>gentalha!</EM></B> e com o especial <B><CODE>\&amp;</CODE></B> que referencia todo o trecho casado e o retrovisor um, que neste caso têm mesmo conteúdo, obtemos a frase clássica que o <EM>Seu Madruga</EM> ouve após apanhar: "Gentalha! Gentalha! Prrrr!".
<P>O que é realmente diferente de tudo no emacs são suas "classes de sintaxe", que são seus similares para as classes POSIX e um algo mais. A sintaxe para acessar essas classes é <B><CODE>\s&lt;identificador&gt;</CODE></B>, em que o identificador pode ser:
<P>
<BLOCKQUOTE><CODE>
<PRE>
ident.  nome            casa um caractere que...
--------------------------------------------------
/       charquote       escapa o próximo caractere
\       escape          inicia um escape tipo C
(       open            abre um bloco
)       close           fecha de um bloco
&lt;    comment         inicia um comentário
&gt;    endcomment      termina um comentário
,       quote           marca um texto normal
"       string          delimita uma string
-       whitespace      é branco
.       punct           é pontuação
w       word            é parte de uma palavra
_       symbol          não é parte de palavra
</PRE>
</CODE></BLOCKQUOTE>
<P>O detalhe é que você mesmo pode alterar o conteúdo dessas classes antes de utilizá-las, dependendo de suas necessidades. O comando <CODE>describe-syntax</CODE> mostra os valores atuais dessas classes, para conferência.
<P>E como era de se esperar <B><CODE>\S</CODE></B> (com S maiúsculo) casa exatamente o oposto, sendo <B><CODE>\S-</CODE></B> qualquer coisa fora brancos, e assim vai...
<P>Ops, quase me esqueci do mais importante: é <B>GNU</B> emacs...
<UL>
<LI>
<A HREF="http://www.gnu.org/software/emacs/emacs.html">http://www.gnu.org/software/emacs/emacs.html</A></LI>
</UL>
<HR>
<A HREF="guia-er-50.html">Página seguinte</A>
<A HREF="guia-er-48.html">Página anterior</A>
<A HREF="guia-er.html#toc6">Índice</A>
</BODY>
</HTML>
