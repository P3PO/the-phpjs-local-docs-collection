

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>カラム &mdash; Doctrine 1.2.4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Doctrine 1.2.4 documentation" href="../../index.html" />
    <link rel="up" title="Manual" href="index.html" />
    <link rel="next" title="テストスキーマを定義する" href="working-with-models.html" />
    <link rel="prev" title="はじめに" href="introduction-to-models.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="working-with-models.html" title="テストスキーマを定義する"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="introduction-to-models.html" title="はじめに"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Manual</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>以前述べたように、Doctrineの最も低いレベルにおいてスキーマはデータベーステーブル用のスキーマメタデータをマッピングするPHPクラスの一式で表現されます。</p>
<p>この章ではPHPコードを使用してスキーマ情報をマッピングする方法を詳しく説明します。</p>
<div class="section" id="id1">
<h1>カラム<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>データベースの互換性の問題の1つは多くのデータベースにおいて返されるクエリの結果セットが異なることです。MySQL
はフィールドの名前はそのままにします。このことは``&#8221;SELECT myField FROM
...&#8221;<a href="#id2"><span class="problematic" id="id3">``</span></a>形式のクエリを発行する場合、結果セットは``myField``のフィールドを含むことを意味します。</p>
<p>不幸にして、これはMySQLとその他のいくつかのデータベースだけの挙動です。例えばPostgresはすべてのフィールド名を小文字で返す一方でOracleは大文字ですべてのフィールド名を返します。&#8221;だから何？Doctrineを使う際にこれがどのような方法で影響を及ぼすの？&#8221;、と疑問に思うかもしれません。幸いにして、この問題を悩む必要はまったくありません。</p>
<p>Doctrineはこの問題を透過的に考慮します。Record派生クラスを定義し``myField``という名前のフィールドを定義する場合、MySQLもしくはPostgresもしくはOracleその他を使おうが、<tt class="docutils literal"><span class="pre">:code:`record-&gt;myField</span></tt> (もしくは```record[&#8216;myField&#8217;]``、好きな方で)を通してアクセスできることを意味します。</p>
<p>要するに:
under_scores(アンダースコア)、camelCase(キャメルケース)もしくは望む形式を使用してフィールドを好きなように名付けることができます。</p>
<blockquote>
<div><strong>NOTE</strong>
Doctrineにおいてカラムとカラムのエイリアスは大文字と小文字を区別します。DQLクエリでカラムを使用するとき、カラム/フィールドの名前はモデルの定義のケースにマッチしなければなりません。</div></blockquote>
<div class="section" id="id4">
<h2>カラムのエイリアス<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Doctrineはカラムのエイリアスを定義する方法を提供します。これはデータベースのロジックからアプリケーションのロジックを分離するのを維持したい場合にとても役に立ちます。例えば
データベースフィールドの名前を変更したい場合、アプリケーションで変更する必要のあるのはカラムの定義だけです。</p>
<blockquote>
<div>// models/Book.php</div></blockquote>
<p>class Book extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;bookTitle as title&#8217;, &#8216;string&#8217;);
} }</p>
<p>下記のコードはYAMLフォーマットのサンプルです。[doc yaml-schema-files
:name]の章でYAMLの詳しい情報を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Book: columns: bookTitle: name: bookTitle as title type: string</p>
<p>Now
データベースのカラムはbookTitleという名前ですがtitleを使用してオブジェクトのプロパティにアクセスできます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $book = new Book(); $book-&gt;title = &#8216;Some book&#8217;; $book-&gt;save();</p>
</div>
<div class="section" id="id5">
<h2>デフォルトの値<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Doctrineはすべてのデータ型のデフォルト値をサポートします。デフォルト値がレコードのカラムに付属するとき2つのことを意味します。まずこの値はすべての新しく作成されたRecordに添付されDoctrineがデータベースを作成するときにcreate
tableステートメントにデフォルト値を含めます。</p>
<blockquote>
<div>// models/generated/BaseUser.php</div></blockquote>
<p>class User extends BaseUser { public function setTableDefinition() {
$this-&gt;hasColumn(&#8216;username&#8217;, &#8216;string&#8217;, 255, array(&#8216;default&#8217; =&gt; &#8216;default
username&#8217;));</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットのサンプルコードは次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>User: # ... columns: username: type: string(255) default: default
username # ...</p>
<p>真新しいUserレコードで名前を表示するときデフォルト値が表示されます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = new User(); echo $user-&gt;username; //
デフォルトのユーザー名</p>
</div>
<div class="section" id="id6">
<h2>データの型<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>はじめに<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>データベースフィールドに保存できる情報用にすべてのDBMSはデータの型の複数の選択肢を提供します。しかしながら、利用可能なデータ型の一式はDBMSによって異なります。</p>
<p>DoctrineによってサポートされるDBMSでインターフェイスを簡略化するために、内在するDBMSにおいてアプリケーションが個別にアクセスできるデータ型の基本セットが定義されました</p>
<p>Doctrineのアプリケーションプログラミングインターフェイスはデータベースオプションを管理する際にデータ型のマッピングを考慮します。それぞれのドライバを使用して内在するDBMSに送るかつDBMSから受け取るものを変換することも可能です。</p>
<p>次のデータ型の例ではDoctrineの``createTable()``メソッドを使います。データ型セクションの最後の配列の例では選んだDBMSでポータブルなテーブルを作成するために``createTable()``メソッドを使うことがあります(何のDBMSが適切にサポートされているか理解するためにDoctrineのメインドキュメントを参照してくださるようお願いします)。次の例ではインデックスの作成と維持はカバーされないことも注意してください。この章はデータ型と適切な使い方のみを考慮します。</p>
<p>アプリケーションレベルでバリデートされた長さ(Doctrineバリデータでバリデートされた長さ)と同様に、カラムの長さはデータベースレベルで影響があることを気を付けてください。</p>
<p>例 1.
&#8216;string&#8217;型と長さ3000の&#8217;content&#8217;という名前のカラムはデータベースレベルの長さ4000を持つ&#8217;TEXT&#8217;データベースの型になります。しかしながらレコードがバリデートされるとき最大長が3000である&#8217;content&#8217;カラムを持つことのみ許可されます。</p>
<p>例 2.
多くのデータベースでは&#8217;integer&#8217;型と長さ1を持つカラムは&#8217;TINYINT&#8217;になります。</p>
<p>一般的に
Doctrineは指定された長さによってどのinteger/string型を使うのか知っているほど賢いです。</p>
</div>
<div class="section" id="id8">
<h3>型修飾子<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Doctrine APIの範囲内で
オプションのテーブルデザインに役立つように設計された修飾子が少しあります:</p>
<ul class="simple">
<li>notnull修飾子</li>
<li>length修飾子</li>
<li>default修飾子</li>
<li>フィールド定義用のunsigned修飾子、integerフィールド型に対して
すべてのDBMSはこの修飾子をサポートしません。</li>
<li>collation修飾子(すべてのドライバでサポートされない)</li>
<li>フィールド定義用の固定長修飾子</li>
</ul>
<p>上記の内容に基づいて話しを進めると、特定の使い方のシナリオ用の特定のフィールドの型を作成するために、修飾子がフィールド定義を変更することが言えます。DBMSのフィールド値の定義によって、フィールド上でデフォルトのDBMS
NOT NULL
Flagをtrueもしくはfalseに設定するためにnotnull修飾子は次の方法で使われます:
PostgreSQLにおいて&#8221;NOT NULL&#8221;の定義は&#8221;NOT
NULL&#8221;に設定される一方で、(例えば)MySQLでは&#8221;NULL&#8221;オプションは&#8221;NO&#8221;に設定されます。&#8221;NOT
NULL&#8221;フィールド型を定義するために、定義配列に追加パラメータを追加するだけです(例は次のセクションを参照)。</p>
<blockquote>
<div>&#8216;sometime&#8217; = array( &#8216;type&#8217; =&gt; &#8216;time&#8217;, &#8216;default&#8217; =&gt; &#8216;12:34:05&#8217;,</div></blockquote>
<p>&#8216;notnull&#8217; =&gt; true, ),</p>
<p>上記の例を利用することで、デフォルトのフィールド演算子も研究できます。フィールド用のデフォルト値はnotnull演算子と同じ方法で設定されます。この値はDBMSがテキストフィールド用にサポートする文字集合、フィールドのデータ型用の他の有効な値に設定されます。上記の例において、&#8221;Time&#8221;データ型に対して有効な時間である&#8216;12:34:05&#8217;を指定しました。datetimeと同じく日付と時間を設定するとき、調べて選択したDBMSのエポックの範囲に収まるようにすべきであることを覚えておいてください。さもなければエラーを診断するのが困難な状況に遭遇します！</p>
<blockquote>
<div>&#8216;sometext&#8217; = array( &#8216;type&#8217; =&gt; &#8216;string&#8217;, &#8216;length&#8217; =&gt; 12, ),</div></blockquote>
<p>上記の例ではデータベースのテーブルで長さ12のフィールドを変更する文字が作られます。長さの定義が省略される場合、Doctrineは指定されたデータ型で許容される最大長を作成されます。これはフィールドの型とインデックス作成において問題を引き起こす可能性があります。ベストプラクティスはすべてもしくは大抵のフィールドに対して長さを定義することです。</p>
</div>
<div class="section" id="id9">
<h3>論理型<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>論理型は0か1の2つの値のどちらかだけを表します。効率性の観点からDBMSドライバの中には単独の文字のテキストフィールドで整数型を実装するものがあるのでこれらの論理型を整数型として保存されることを想定しないでください。この型のフィールドに割り当てできる3番目の利用可能な値としてnullを使うことで三値論理は可能です。</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
次のいくつかの例では使ったり試したりすることを想定していません。これらは単にPHPコードもしくはYAMLスキーマファイルを利用してDoctrineの異なるデータ型を使う方法を示すことだけを目的としています。</div></blockquote>
<p>class Test extends Doctrine_Record { public function</p>
</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;booltest&#8217;, &#8216;boolean&#8217;); } }</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細内容を見ることができます:</p>
<blockquote>
<div>Test: columns: booltest: boolean</div></blockquote>
</div>
<div class="section" id="id10">
<h3>整数型<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>整数型はPHPの整数型と同じです。それぞれのDBMSが扱える大きさの整数型の値を保存します。</p>
<p>オプションとしてこの型のフィールドは符号なしの整数として作成されますがすべてのDBMSはこれをサポートしません。それゆえ、このようなオプションは無視されることがあります。本当にポータルなアプリケーションはこのオプションの利用可能性に依存すべきではありません。</p>
<p>整数型はカラムの長さによって異なるデータベースの型にマッピングされます。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;integertest&#8217;, &#8216;integer&#8217;, 4,
array( &#8216;unsigned&#8217; =&gt; true ) ); } }</p>
<p>YAMLフォーマットでの例です。[doc yaml-schema-files
:name]の章っでYAMLの詳細情報を読むことができます:</p>
<blockquote>
<div>Test: columns: integertest: type: integer(4) unsigned: true</div></blockquote>
</div>
<div class="section" id="id11">
<h3>浮動小数点型<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>浮動小数点のデータ型は10進法の浮動小数点数を保存できます。このデータ型は高い精度を必要としない大きなスケールの範囲の数値を表現するのに適しています。スケールと精度に関してデータベースに保存される値の制限は使用されるDBMSに依存します。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;floattest&#8217;, &#8216;float&#8217;); } }</p>
<p>下記のコードはYAMLフォーマットでの例です。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote>
<div>Test: columns: floattest: float</div></blockquote>
</div>
<div class="section" id="id12">
<h3>小数型<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>小数型のデータは固定精度の小数を保存できます。このデータ型は高い正確度と精度を必要とする数値を表現するのに適しています。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;decimaltest&#8217;, &#8216;decimal&#8217;); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を学ぶことができます:</p>
<blockquote>
<div>Test: columns: decimaltest: decimal</div></blockquote>
<p>他のカラムの``length``を設定するように小数の長さを指定することが可能で3番目の引数でオプションとして``scale``を指定できます:</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;decimaltest&#8217;, &#8216;decimal&#8217;, 18,
array( &#8216;scale&#8217; =&gt; 2 ) ); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報をみることができます:</p>
<blockquote>
<div>Test: columns: decimaltest: type: decimal(18) scale: 2</div></blockquote>
</div>
<div class="section" id="id13">
<h3>文字列型<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>テキストデータ型では長さに対して2つのオプションが利用可能です:
1つは明示的に制限された長さでもう一つはデータベースが許容する限りの大きさの未定義の長さです。</p>
<p>効率の点で制限オプション付きの長さは大抵の場合推奨されます。未定義の長さオプションはとても大きなフィールドを許可しますがインデックスとnullの利用を制限することがあり、その型のフィールド上でのソートを許可しません。</p>
<p>この型のフィールドは8ビットの文字を扱うことができます。文字列の値をこの型に変換することでドライバはDBMSで特別な意味を持つ文字のエスケープを考慮します。</p>
<p>デフォルトではDoctrineは可変長の文字型を使用します。固定長の型が使われる場合、fixed修飾子を通してコントロールできます。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;stringtest&#8217;, &#8216;string&#8217;, 200,
array( &#8216;fixed&#8217; =&gt; true ) ); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を見ることができます:</p>
<blockquote>
<div>Test: columns: stringtest: type: string(200) fixed: true</div></blockquote>
</div>
<div class="section" id="id14">
<h3>配列<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>これはPHPの&#8217;array&#8217;型と同じです。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;arraytest&#8217;, &#8216;array&#8217;, 10000); }
}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を見ることができます:</p>
<blockquote>
<div>Test: columns: arraytest: array(10000)</div></blockquote>
</div>
<div class="section" id="id15">
<h3>オブジェクト<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>Doctrineはオブジェクトをカラム型としてサポートします。基本的にオブジェクトをフィールドに設定可能でDoctrineはそのオブジェクトのシリアライズ/アンシリアライズを自動的に処理します。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;objecttest&#8217;, &#8216;object&#8217;); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote>
<div><p>Test: columns: objecttest: object</p>
<blockquote>
<div><strong>NOTE</strong>
配列とオブジェクト型はデータベースで永続化するときはデータをシリアライズしデータベースから引き出すときはデータをアンシリアライズします</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="blob">
<h3>blob<a class="headerlink" href="#blob" title="Permalink to this headline">¶</a></h3>
<p>blob(Binary Large
OBject)データ型は、通常はファイルに保存されるデータのようにテキストフィールドに大きすぎる未定義の長さのデータを保存することを意味します。</p>
<p>内在するDBMSが&#8221;全文検索&#8221;として知られる機能をサポートしない限りblobフィールドはエリーの検索句(<tt class="docutils literal"><span class="pre">WHERE</span></tt>)のパラメータを使用することを意味しません。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;blobtest&#8217;, &#8216;blob&#8217;); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: blobtest: blob</div></blockquote>
</div>
<div class="section" id="clob">
<h3>clob<a class="headerlink" href="#clob" title="Permalink to this headline">¶</a></h3>
<p>clob (Character Large
OBject)データ型は、通常はファイルに保存されるデータのように、テキストフィールドで保存するには大きすぎる未定義の長さのデータを保存することを意味します。</p>
<p>blogフィールドがデータのすべての型を保存するのが想定されているのに対してclobフィールドは印字可能なASCII文字で構成されるデータのみを保存することを想定しています。</p>
<p>内在するDBMSが&#8221;全文検索&#8221;として知られる機能をサポートしない限りclobフィールドはクエリ検索句(WHERE)のパラメータとして使われることが想定されています。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;clobtest&#8217;, &#8216;clob&#8217;); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: clobtest: clob</div></blockquote>
</div>
<div class="section" id="timestamp">
<h3>timestamp<a class="headerlink" href="#timestamp" title="Permalink to this headline">¶</a></h3>
<p>timestampデータ型は日付と時間のデータ型の組み合わせに過ぎません。timestamp型の値の表記は日付と時間の文字列の値は1つのスペースで連結することで実現されます。それゆえ、フォーマットのテンプレートは``YYYY-MM-DD
HH:MI:SS``です。表される値は日付と時間データ型で説明したルールと範囲に従います。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;timestamptest&#8217;, &#8216;timestamp&#8217;); }
}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: timestamptest: timestamp</div></blockquote>
</div>
<div class="section" id="time">
<h3>time<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h3>
<p>timeデータ型はその日の与えられた瞬間の時間を表します。DBMS独自の時間の表記もISO-8601標準に従ってテキストの文字列を使用することで実現できます。</p>
<p>日付の時間用にISO-8601標準で定義されたフォーマットはHH:MI:SSでHHは時間で00から23まででMIとSSは分と秒で00から59までです。時間、分と秒は10より小さな数値の場合は左側に0が詰められます。</p>
<p>DBMSの中にはネイティブで時間フォーマットをサポートするものがありますが、DBMSドライバの中にはこれらを整数もしくはテキストの文字列として表現しなければならないものがあります。ともかく、この型のフィールドによるソートクエリの結果と同じように時間の値の間で比較することは常に可能です。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;timetest&#8217;, &#8216;time&#8217;); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: timetest: time</div></blockquote>
</div>
<div class="section" id="date">
<h3>date<a class="headerlink" href="#date" title="Permalink to this headline">¶</a></h3>
<p>dateデータ型は年、月と日にちのデータを表します。DBMS独自の日付の表記はISO-8601標準の書式のテキスト文字列を使用して実現されます。</p>
<p>日付用にISO-8601標準で定義されたフォーマットはYYYY-MM-DDでYYYYは西暦の数字(グレゴリオ暦)、MMは01から12までの月でDDは01か31までの日の数字です。10より小さい月の日にちの数字には左側に0が追加されます。</p>
<p>DBMSの中にはネイティブで日付フォーマットをサポートするものがありますが、他のDBMSドライバではこれらを整数もしくはテキストの値として表現しなければならないことがあります。どの場合でも、この型のフィールドによるソートクエリの結果によって日付の間の比較は常に可能です。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;datetest&#8217;, &#8216;date&#8217;); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: datetest: date</div></blockquote>
</div>
<div class="section" id="enum">
<h3>enum<a class="headerlink" href="#enum" title="Permalink to this headline">¶</a></h3>
<p>Doctrineはunifiedなenum型を持ちます。カラムに対して可能な値は``Doctrine_Record::hasColumn()``でカラム定義に指定できます。</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
DBMSに対してネイティブのenum型を使用したい場合次の属性を設定しなければなりません:</div></blockquote>
<p>$conn-&gt;setAttribute(Doctrine_Core::ATTR_USE_NATIVE_ENUM, true);</p>
</div></blockquote>
<p>次のコードはenumの値を指定する方法の例です:</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;enumtest&#8217;, &#8216;enum&#8217;, null,
array(&#8216;values&#8217; =&gt; array(&#8216;php&#8217;, &#8216;java&#8217;, &#8216;python&#8217;)) ); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Test: columns: enumtest: type: enum values: [php, java, python]</div></blockquote>
</div>
<div class="section" id="gzip">
<h3>gzip<a class="headerlink" href="#gzip" title="Permalink to this headline">¶</a></h3>
<p>gzipデータ型は存続するときに自動的に圧縮取得されたときに解凍される以外は文字列と同じです。ビットマップ画像など、大きな圧縮率でデータを保存するときにこのデータ型は役に立ちます。</p>
<blockquote>
<div>class Test extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;gziptest&#8217;, &#8216;gzip&#8217;); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div><p>Test: columns: gziptest: gzip</p>
<blockquote>
<div><strong>NOTE</strong>
内部ではgzipカラム型の内容の圧縮と解凍を行うために[<a class="reference external" href="http://www.php.net/gzcompress">http://www.php.net/gzcompress</a>
圧縮]系のPHP関数が使われています。</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="id16">
<h2>例<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>次の定義を考えましょう:</p>
<blockquote>
<div>class Example extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;id&#8217;, &#8216;string&#8217;, 32, array(
&#8216;type&#8217; =&gt; &#8216;string&#8217;, &#8216;fixed&#8217; =&gt; 1, &#8216;primary&#8217; =&gt; true, &#8216;length&#8217; =&gt; &#8216;32&#8217; )
);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;someint&#39;</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;unsigned&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;10&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;sometime&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
            <span class="s1">&#39;default&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;12:34:05&#39;</span><span class="p">,</span>
            <span class="s1">&#39;notnull&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;25&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;sometext&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;12&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;somedate&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;25&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;sometimestamp&#39;</span><span class="p">,</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;25&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;someboolean&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;boolean&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;25&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;somedecimal&#39;</span><span class="p">,</span> <span class="s1">&#39;decimal&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;decimal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;18&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;somefloat&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2147483647&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;someclob&#39;</span><span class="p">,</span> <span class="s1">&#39;clob&#39;</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;clob&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2147483647&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;someblob&#39;</span><span class="p">,</span> <span class="s1">&#39;blob&#39;</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;blob&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2147483647&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>Example: tableName: example columns: id: type: string(32) fixed: true</div></blockquote>
<p>primary: true someint: type: integer(10) unsigned: true sometime: type:
time(25) default: &#8216;12:34:05&#8217; notnull: true sometext: string(12)
somedate: date(25) sometimestamp: timestamp(25) someboolean: boolean(25)
somedecimal: decimal(18) somefloat: float(2147483647) someclob:
clob(2147483647) someblob: blob(2147483647)</p>
<p>上記の例はPgsqlで次のテーブルが作成します:</p>
<p>||~ カラム ||~ 型 || || <tt class="docutils literal"><span class="pre">id</span></tt> || <tt class="docutils literal"><span class="pre">character(32)</span></tt> || ||
<tt class="docutils literal"><span class="pre">someint</span></tt> || <tt class="docutils literal"><span class="pre">integer</span></tt> || || <tt class="docutils literal"><span class="pre">sometime</span></tt> ||
タイムゾーンなしの``time`` || || <tt class="docutils literal"><span class="pre">sometext</span></tt> ||
<tt class="docutils literal"><span class="pre">character``もしくは``varying(12)</span></tt> || || <tt class="docutils literal"><span class="pre">somedate</span></tt> ||
<tt class="docutils literal"><span class="pre">date</span></tt> || || <tt class="docutils literal"><span class="pre">sometimestamp</span></tt> ||
タイムゾーンなしの``timestamp`` || || <tt class="docutils literal"><span class="pre">someboolean</span></tt> ||
<tt class="docutils literal"><span class="pre">boolean</span></tt> || || <tt class="docutils literal"><span class="pre">somedecimal</span></tt> || <tt class="docutils literal"><span class="pre">numeric(18,2)</span></tt> || ||
<tt class="docutils literal"><span class="pre">somefloat</span></tt> || <tt class="docutils literal"><span class="pre">double``の精度</span> <span class="pre">\|\|</span> <span class="pre">\|\|</span> <span class="pre">``someclob</span></tt> || <tt class="docutils literal"><span class="pre">text</span></tt>
|| || <tt class="docutils literal"><span class="pre">someblob</span></tt> || <tt class="docutils literal"><span class="pre">bytea</span></tt> ||</p>
<p>Mysqlではスキーマは次のデータベーステーブルを作成します:</p>
<p>||~ フィールド ||~ 型 || || <tt class="docutils literal"><span class="pre">id</span></tt> || <tt class="docutils literal"><span class="pre">char(32)</span></tt> || ||
<tt class="docutils literal"><span class="pre">someint</span></tt> || <tt class="docutils literal"><span class="pre">integer</span></tt> || || <tt class="docutils literal"><span class="pre">sometime</span></tt> || <tt class="docutils literal"><span class="pre">time</span></tt> ||
|| <tt class="docutils literal"><span class="pre">sometext</span></tt> || <tt class="docutils literal"><span class="pre">varchar(12)</span></tt> || || <tt class="docutils literal"><span class="pre">somedate</span></tt> ||
<tt class="docutils literal"><span class="pre">date</span></tt> || || <tt class="docutils literal"><span class="pre">sometimestamp</span></tt> || <tt class="docutils literal"><span class="pre">timestamp</span></tt> || ||
<tt class="docutils literal"><span class="pre">someboolean</span></tt> || <tt class="docutils literal"><span class="pre">tinyint(1)</span></tt> || || <tt class="docutils literal"><span class="pre">somedecimal</span></tt> ||
<tt class="docutils literal"><span class="pre">decimal(18,2)</span></tt> || || <tt class="docutils literal"><span class="pre">somefloat</span></tt> || <tt class="docutils literal"><span class="pre">double</span></tt> || ||
<tt class="docutils literal"><span class="pre">someclob</span></tt> || <tt class="docutils literal"><span class="pre">longtext</span></tt> || || <tt class="docutils literal"><span class="pre">someblob</span></tt> || <tt class="docutils literal"><span class="pre">longblob</span></tt>
||</p>
</div>
</div>
<div class="section" id="id17">
<h1>リレーション<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id18">
<h2>はじめに<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>Doctrineにおいてすべてのレコードのリレーションは``Doctrine_Record::hasMany``、<a href="#id19"><span class="problematic" id="id20">``</span></a>Doctrine_Record::hasOne``メソッドで設定されます。Doctrineはほとんどの種類のデータベースリレーションをサポートします
from
一対一のシンプルな外部キーのリレーションから自己参照型のリレーションまでサポートします。</p>
<p>カラムの定義とは異なり``Doctrine_Record::hasMany``と``Doctrine_Record::hasOne``メソッドは``setUp()``と呼ばれるメソッドの範囲内で設置されます。両方のメソッドは2つの引数を受け取ります:
最初の引数はクラスの名前とオプションのエイリアスを含む文字列で、2番目の引数はリレーションのオプションで構成される配列です。オプションの配列は次のキーを含みます:</p>
<p>||~ 名前 ||~ オプション ||~ 説明 || || <tt class="docutils literal"><span class="pre">local</span></tt> || No ||
リレーションのローカルフィールド。ローカルフィールドはクラスの定義ではリンク付きのフィールド。
|| || <tt class="docutils literal"><span class="pre">foreign</span></tt> || No ||
リレーションの外部フィールド。外部フィールドはリンク付きのクラスのリンク付きフィールドです。||
|| <tt class="docutils literal"><span class="pre">refClass</span></tt> || Yes ||
アソシエーションクラスの名前。これは多対多のアソシエーションに対してのみ必要です。||
|| <tt class="docutils literal"><span class="pre">owningSide</span></tt>|| Yes ||
所有側のリレーションを示すには論理型のtrueを設定します。所有側とは外部キーを所有する側です。2つのクラスの間のアソシエーションにおいて所有側は1つのみです。Doctrineが所有側を推測できないもしくは間違った推測をする場合このオプションが必須であることに注意してください。&#8217;local&#8217;と&#8217;foreign&#8217;の両方が識別子(主キー)の一部であるときこれが当てはまります。この方法で所有側を指定することは害になることはありません。||
|| <tt class="docutils literal"><span class="pre">onDelete</span></tt> || Yes ||
Doctrineによってテーブルが適用されるときに``onDelete``整合アクションが外部キー制約に適用されます。
|| || <tt class="docutils literal"><span class="pre">onUpdate</span></tt> || Yes ||
Doctrineによってテーブルが作成されたときに``onUpdate``整合アクションが外部キー制約に適用されます。||
|| <tt class="docutils literal"><span class="pre">cascade</span></tt> || Yes ||
オペレーションをカスケーディングするアプリケーションレベルを指定する。現在削除のみサポートされる
||</p>
<p>最初の例として、<a href="#id21"><span class="problematic" id="id22">``</span></a>Forum_Board``と``Forum_Thread``の2つのクラスがあるとします。リレーションが一対多なので、<a href="#id23"><span class="problematic" id="id24">``</span></a>Forum_Board``は多くの``Forum_Threads``を持ちます。リレーションにアクセスする際に``Forum_``を書きたくないので、リレーションのエイリアスを使用しエイリアスの``Threads``を使用します。</p>
<p>最初に``Forum_Board``クラスを見てみましょう。これはカラム: 名前,
説明を持ち主キーを指定していないので、Doctrineはidカラムを自動作成します。</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a>hasMany()``メソッドを使用することで``Forum_Thread``クラスへのリレーションを定義します。localフィールドがboardクラスの主キーである一方でforeignフィールドが``Forum_Thread``クラスの``board_id``フィールドです。</p>
<blockquote>
<div>// models/Forum_Board.php</div></blockquote>
<p>class Forum_Board extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 100);
$this-&gt;hasColumn(&#8216;description&#8217;, &#8216;string&#8217;, 5000); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Forum_Thread as Threads&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;board_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<blockquote>
<div><strong>NOTE</strong>
asキーワードが使われていることに注目してください。このことは``Forum_Board``が``Forum_Thread``に定義された多数のリレーションを持ちますが``Threads``のエイリアスが設定されることを意味します。</div></blockquote>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Forum_Board: columns: name: string(100) description: string(5000)</p>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a>Forum_Thread``クラスの内容を少しのぞいて見ましょう。カラムの内容は適当ですが、リレーションの定義方法に注意をはらってください。それぞれの``Thread``は1つの``Board``のみを持つことができるので``hasOne()``メソッドを使っています。またエイリアスの使い方とlocalカラムが``board_id``である一方で外部カラムは``id``カラムであることに注目してください。</p>
<blockquote>
<div>// models/Forum_Thread.php</div></blockquote>
<p>class Forum_Thread extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;);
$this-&gt;hasColumn(&#8216;board_id&#8217;, &#8216;integer&#8217;); $this-&gt;hasColumn(&#8216;title&#8217;,
&#8216;string&#8217;, 200); $this-&gt;hasColumn(&#8216;updated&#8217;, &#8216;integer&#8217;, 10);
$this-&gt;hasColumn(&#8216;closed&#8217;, &#8216;integer&#8217;, 1); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Forum_Board as Board&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;board_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Forum_Thread: columns: user_id: integer board_id: integer title:
string(200) updated: integer(10) closed: integer(1) relations: User:
local: user_id foreign: id foreignAlias: Threads Board: class:
Forum_Board local: board_id foreign: id foreignAlias: Threads</p>
<p>これらのクラスを使い始めることができます。プロパティに既に使用した同じアクセサはリレーションに対してもすべて利用できます。</p>
<p>最初に新しいboardを作りましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $board = new Forum_Board(); $board-&gt;name = &#8216;Some board&#8217;;</p>
<p>boardの元で新しいthreadを作りましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $board-&gt;Threads[0]-&gt;title = &#8216;new thread 1&#8217;;
$board-&gt;Threads[1]-&gt;title = &#8216;new thread 2&#8217;;</p>
<p>それぞれの``Thread``はそれぞれのユーザーに関連付ける必要があるので新しい``User``を作りそれぞれの``Thread``に関連付けましょう:</p>
<blockquote>
<div>$user = new User(); $user-&gt;username = &#8216;jwage&#8217;; $board-&gt;Threads[0]-&gt;User</div></blockquote>
<p>= $user; $board-&gt;Threads[1]-&gt;User = $user;</p>
<p>これですべての変更を1つの呼び出しで保存できます。threadsと同じように新しいboardを保存します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $board-&gt;save();</p>
<p>上記のコードを使うときに作成されるデータ構造を見てみましょう。投入したばかりのオブジェクトグラフの配列を出力するために``test.php``にコードを追加します:</p>
<blockquote>
<div><p>print_r($board-&gt;toArray(true));</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">レコードのデータを簡単にインスペクトできるように``Doctrine_Record::toArray()``は``Doctrine_Record``インスタンスのすべてのデータを取り配列に変換します。これはリレーションを含めるかどうかを伝える``$deep``という名前の引数を受け取ります。この例では``Threads``のデータを含めたいので{[true]}を指定しました。</p>
</div>
</div></blockquote>
<p>ターミナルで``test.php``を実行すると次の内容が表示されます:</p>
<blockquote>
<div>$ php test.php Array ( [id] =&gt; 2 [name] =&gt; Some board [description] =&gt;</div></blockquote>
<p>[Threads] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 3 [user_id] =&gt; 1
[board_id] =&gt; 2 [title] =&gt; new thread 1 [updated] =&gt; [closed] =&gt; [User]
=&gt; Array ( [id] =&gt; 1 [is_active] =&gt; 1 [is_super_admin] =&gt; 0
[first_name] =&gt; [last_name] =&gt; [username] =&gt; jwage [password] =&gt;
[type] =&gt; [created_at] =&gt; 2009-01-20 16:41:57 [updated_at] =&gt;
2009-01-20 16:41:57 )</p>
<div class="highlight-php"><div class="highlight"><pre>        <span class="p">)</span>

    <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="k">Array</span>
        <span class="p">(</span>
            <span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">4</span>
            <span class="p">[</span><span class="nx">user_id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">1</span>
            <span class="p">[</span><span class="nx">board_id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">2</span>
            <span class="p">[</span><span class="nx">title</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">thread</span> <span class="mi">2</span>
            <span class="p">[</span><span class="nx">updated</span><span class="p">]</span> <span class="o">=&gt;</span>
            <span class="p">[</span><span class="nx">closed</span><span class="p">]</span> <span class="o">=&gt;</span>
            <span class="p">[</span><span class="nx">User</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="k">Array</span>
                <span class="p">(</span>
                    <span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">1</span>
                    <span class="p">[</span><span class="nx">is_active</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">1</span>
                    <span class="p">[</span><span class="nx">is_super_admin</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">0</span>
                    <span class="p">[</span><span class="nx">first_name</span><span class="p">]</span> <span class="o">=&gt;</span>
                    <span class="p">[</span><span class="nx">last_name</span><span class="p">]</span> <span class="o">=&gt;</span>
                    <span class="p">[</span><span class="nx">username</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nx">jwage</span>
                    <span class="p">[</span><span class="nx">password</span><span class="p">]</span> <span class="o">=&gt;</span>
                    <span class="p">[</span><span class="nx">type</span><span class="p">]</span> <span class="o">=&gt;</span>
                    <span class="p">[</span><span class="nx">created_at</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">2009</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">20</span> <span class="mi">16</span><span class="o">:</span><span class="mi">41</span><span class="o">:</span><span class="mi">57</span>
                    <span class="p">[</span><span class="nx">updated_at</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">2009</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">20</span> <span class="mi">16</span><span class="o">:</span><span class="mi">41</span><span class="o">:</span><span class="mi">57</span>
                <span class="p">)</span>

        <span class="p">)</span>

<span class="p">)</span>
</pre></div>
</div>
<p>)</p>
<blockquote>
<div><strong>NOTE</strong>
Doctrine内部でautoincrementの主キーと外部キーが自動的に設定されることに注意してください。主キーと外部キーの設定に悩む必要はまったくありません！</div></blockquote>
</div>
<div class="section" id="id29">
<h2>外部キーのアソシエーション<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id30">
<h3>一対一<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>一対一のリレーションは最も基本的なリレーションでしょう。次の例ではリレーションが一対一である``User``と``Email``の2つのクラスを考えます。</p>
<p>最初に``Email``クラスを見てみましょう。一対一のリレーションをバインドしているので``hasOne()``メソッドを使用しています。<tt class="docutils literal"><span class="pre">Email``クラスで外部キーのカラム(``user_id</span></tt>)を定義する方法に注目してください。これは``Email``が``User``によって所有され他の方法がないという事実に基づいています。実際次の慣習
- 所有側のクラスで外部キーを設置することに従うべきです。</p>
<p>外部キー用に推奨される命名規約は:
<a href="#id31"><span class="problematic" id="id32">``</span></a>[tableName]_[primaryKey]``です。外部テーブルは&#8217;user&#8217;で主キーは&#8217;id&#8217;なので外部キーのカラムは&#8217;user_id&#8217;と名付けました。</p>
<blockquote>
<div>// models/Email.php</div></blockquote>
<p>class Email extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;);
$this-&gt;hasColumn(&#8216;address&#8217;, &#8216;string&#8217;, 150); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Email: columns: user_id: integer address: string(150) relations: User:
local: user_id foreign: id foreignType: one</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">リレーションは自動的に反転して追加されるので、YAMLスキーマファイルを使用するとき反対端(<tt class="docutils literal"><span class="pre">User</span></tt>)でリレーションを指定することは必須ではありません。リレーションはクラスの名前から名付けられます。ですのでこの場合``User``側のリレーションは``Email``と呼ばれ``many``になります。これをカスタマイズしたい場合``foreignAlias``と``foreignType``オプションを使用できます。</p>
</div>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a>Email``クラスは``User``クラスとよく似ています。localとforeignカラムは``Email``クラスの定義と比較される``hasOne()``の定義に切り替えられることに注目してください。</p>
<blockquote>
<div>// models/User.php</div></blockquote>
<p>class User extends BaseUser { public function setUp() { parent::setUp();</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Email&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<blockquote>
<div><strong>NOTE</strong>
<a href="#id35"><span class="problematic" id="id36">``</span></a>setUp()``メソッドをオーバーライドして``parent::setUp()``を呼び出していることに注目してください。これはYAMLもしくは既存のデータベースから生成された``BaseUser``クラスがメインの``setUp()``メソッドを持ちリレーションを追加するために``User``クラスでこのメソッドをオーバーライドしているからです。</div></blockquote>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>User: # ... relations: # ... Email: local: id foreign: user_id</p>
</div>
<div class="section" id="id37">
<h3>一対多と多対一<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<p>一対多と多対一のリレーションは一対一のリレーションとよく似ています。以前の章で見た推奨される慣習は一対多と多対一のリレーションにも適用されます。</p>
<p>次の例では2つのクラス:
<a href="#id38"><span class="problematic" id="id39">``</span></a>User``と``Phonenumber``があります。一対多のリレーションとして定義します(ユーザーは複数の電話番号を持つ)。繰り返しますが``Phonenumber``は``User``によって所有されるので``Phonenumber``クラスに外部キーを設置します。</p>
<blockquote>
<div>// models/User.php</div></blockquote>
<p>class User extends BaseUser { public function setUp() { parent::setUp();</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Phonenumber as Phonenumbers&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>// models/Phonenumber.php</p>
<p>class Phonenumber extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;);
$this-&gt;hasColumn(&#8216;phonenumber&#8217;, &#8216;string&#8217;, 50); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>User: # ... relations: # ... Phonenumbers: type: many class: Phonenumber
local: id foreign: user_id</p>
<p>Phonenumber: columns: user_id: integer phonenumber: string(50)
relations: User: local: user_id foreign: id</p>
</div>
<div class="section" id="id40">
<h3>ツリー構造<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<p>ツリー構造は自己参照の外部キーのリレーションです。次の定義は階層データの概念の用語では隣接リスト(Adjacency
List)とも呼ばれます。</p>
<blockquote>
<div>// models/Task.php</div></blockquote>
<p>class Task extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 100);
$this-&gt;hasColumn(&#8216;parent_id&#8217;, &#8216;integer&#8217;); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Task as Parent&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parent_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Task as Subtasks&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parent_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Task: columns: name: string(100) parent_id: integer relations: Parent:
class: Task local: parent_id foreign: id foreignAlias: Subtasks</p>
<blockquote>
<div><strong>NOTE</strong>
上記の実装は純粋な例で階層データを保存し読み取るための最も効率的な方法ではありません。階層データを扱い推奨方法に関してはDoctrineに含まれる``NestedSet``ビヘイビアを確認してください。</div></blockquote>
</div>
</div>
<div class="section" id="id41">
<h2>テーブルのアソシエーションをジョインする<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id42">
<h3>多対多<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h3>
<p>リレーショナルデータベースの背景知識があれば、多対多のアソシエーションを扱う方法になれているかもしれません:
追加のアソシエーションテーブルが必要です。</p>
<p>多対多のリレーションにおいて2つのコンポーネントの間のリレーションは常に集約関係でアソシエーションテーブルは両端で所有されます。ユーザーとグループの場合:
ユーザーが削除されているとき、ユーザーが所属するグループは削除されません。しかしながら、ユーザーとユーザーが所属するグループの間のアソシエーションが代わりに削除されています。これはユーザーとユーザーが所属するグループの間のリレーションを削除しますが、ユーザーとグループは削除しません。</p>
<p>ときにはユーザー/グループを削除するときアソシエーションテーブルの列を削除したくないことがあります。リレーションをアソシエーションコンポーネントに設定する(このケースでは``Groupuser``)
ことで明示的にこのビヘイビアをオーバーライドできます。</p>
<p>次の例ではリレーションが多対多として定義されているGroupsとUsersがあります。このケースでは``Groupuser``と呼ばれる追加クラスも定義する必要があります。</p>
<blockquote>
<div>class User extends BaseUser public function setUp() { parent::setUp();</div></blockquote>
<div class="highlight-php"><div class="highlight"><pre>    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Group as Groups&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;group_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;refClass&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;UserGroup&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>User: # ... relations: # ... Groups: class: Group local: user_id</div></blockquote>
<p>foreign: group_id refClass: UserGroup</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
多対多のリレーションをセットアップするとき上記の``refClass``オプションは必須です。</div></blockquote>
<p>// models/Group.php</p>
</div></blockquote>
<p>class Group extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;setTableName(&#8216;groups&#8217;);
$this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 30); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;User as Users&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;group_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;refClass&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;UserGroup&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Group: tableName: groups columns: name: string(30) relations: Users:
class: User local: group_id foreign: user_id refClass: UserGroup</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
<a href="#id43"><span class="problematic" id="id44">``</span></a>group``は予約語であることにご注意ください。これが``setTableName``メソッドを使用してテーブルを``groups``にリネームする理由です。予約語がクォートでエスケープされるように他のオプションは``Doctrine::ATTR_QUOTE_IDENTIFIER``属性を使用して識別子のクォート追加を有功にすることです。</div></blockquote>
<p>$manager-&gt;setAttribute(Doctrine_Core::ATTR_QUOTE_IDENTIFIER, true);</p>
<p>// models/UserGroup.php</p>
</div></blockquote>
<p>class UserGroup extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;, null,
array( &#8216;primary&#8217; =&gt; true ) );</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;group_id&#39;</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;primary&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>UserGroup: columns: user_id: type: integer primary: true group_id:
type: integer primary: true</p>
<p>リレーションが双方向であることに注目してください。<a href="#id45"><span class="problematic" id="id46">``</span></a>User``は複数の``Group``を持ち``Group``は複数の``User``を持ちます。Doctrineで多対多のリレーションを完全に機能させるためにこれは必須です。</p>
<p>新しいモデルで遊んでみましょう。ユーザーを作成しこれにいくつかのグループを割り当てます。最初に新しい``User``インス場合も考えてみましょう。注文テーブルが実在する製品の注文のみが含まれることを保証したい場合を考えます。ですので製品テーブルを参照する注文テーブルで外部キー制約を定義します:</p>
<blockquote>
<div>// models/Order.php</div></blockquote>
<p>class Order extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;setTableName(&#8216;orders&#8217;);
$this-&gt;hasColumn(&#8216;product_id&#8217;, &#8216;integer&#8217;); $this-&gt;hasColumn(&#8216;quantity&#8217;,
&#8216;integer&#8217;); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Product&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;product_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Order: tableName: orders columns: product_id: integer quantity: integer
relations: Product: local: product_id foreign: id</p>
<blockquote>
<div><strong>NOTE</strong>
外部キーを含むクエリを発行するときに最適なパフォーマンスを保証するために外部キーのカラムのインデックスは自動的に作成されます。</div></blockquote>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a>Order``クラスがエクスポートされるとき次のSQLが実行されます:</p>
<blockquote>
<div>CREATE TABLE orders ( id integer PRIMARY KEY auto_increment,</div></blockquote>
<p>product_id integer REFERENCES products (id), quantity integer, INDEX
product_id_idx (product_id) )</p>
<p><a href="#id49"><span class="problematic" id="id50">``</span></a>product``テーブルに現れない``product_id``で``orders``を作成するのは不可能です。</p>
<p>この状況においてordersテーブルは参照するテーブルでproductsテーブルはは参照されるテーブルです。同じように参照と参照されるカラムがあります。</p>
</div>
<div class="section" id="id51">
<h3>外部キーの名前<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<p>Doctrineでリレーションを定義し外部キーがデータベースで作成されるとき、Doctrineは外部キーの名前をつけようとします。ときには、その名前が望んだものとは違うことがあるのでリレーションのセットアップで``foreignKeyName``オプションを使うことで名前をカスタマイズできます。</p>
<blockquote>
<div>// models/Order.php</div></blockquote>
<p>class Order extends Doctrine_Record { // ...</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Product&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;product_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreignKeyName&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;product_id_fk&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。YAMLの詳細は[doc
yaml-schema-files :name]の章で読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Order: # ... relations: Product: local: product_id foreign: id
foreignKeyName: product_id_fk</p>
</div>
<div class="section" id="id52">
<h3>整合アクション<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<p><strong>CASCADE</strong></p>
<p>親テーブルから列を削除もしくは更新しコテーブルでマッチするテーブルを自動的に削除もしくは更新します。<a href="#id53"><span class="problematic" id="id54">``</span></a>ON
DELETE CASCADE``と``ON UPDATE
CASCADE``の両方がサポートされます。2つのテーブルの間では、親テーブルもしくは子テーブルの同じカラムで振る舞う``ON
UPDATE CASCADE``句を定義すべきではありません。</p>
<p><strong>SET NULL</strong></p>
<p>親テーブルから列を削除もしは更新し子テーブルで外部キーカラムを``NULL``に設定します。外部キーカラムが``NOT
NULL``修飾子が指定されない場合のみこれは有効です。<a href="#id55"><span class="problematic" id="id56">``</span></a>ON DELETE SET
NULL``と``ON UPDATE SET NULL``句の両方がサポートされます。</p>
<p><strong>NO ACTION</strong></p>
<p>標準のSQLにおいて、<a href="#id57"><span class="problematic" id="id58">``</span></a>NO
ACTION``はアクションが行われないことを意味し、具体的には参照されるテーブルで関連する外部キーの値が存在する場合、主キーの値を削除するもしくは更新する処理が許可されません。</p>
<p><strong>RESTRICT</strong></p>
<p>親テーブルに対する削除もしくは更新オペレーションを拒否します。<a href="#id59"><span class="problematic" id="id60">``</span></a>NO
ACTION``と``RESTRICT``は``ON DELETE``もしくは``ON
UPDATE``句を省略するのと同じです。</p>
<p><strong>SET DEFAULT</strong></p>
<p>次の例において``User``と``Phonenumber``の2つのクラスのリレーションを一対多に定義します。<a href="#id61"><span class="problematic" id="id62">``</span></a>onDelete``カスケードアクションで外部キーの制約も追加します。このことは``user``が削除されるたびに関連する``phonenumbers``も削除されることを意味します。</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
上記で示されている整合性制約は大文字小文字を区別しスキーマで定義するときは大文字でなければなりません。下記のコードは削除カスケードが使用されるデータベース削除の例です。</div></blockquote>
<p>class Phonenumber extends Doctrine_Record { // ...</p>
</div></blockquote>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">parent</span><span class="o">::</span><span class="na">setUp</span><span class="p">();</span>

    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;onDelete&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;CASCADE&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Phonenumber: # ... relations: # ... User: local: user_id foreign: id
onDelete: CASCADE</p>
<blockquote>
<div><strong>NOTE</strong>
外部キーがあるところで整合性制約がおかれていることに注目してください。整合性制約がデータベースのプロパティにエクスポートされるためにこれは必須です。</div></blockquote>
</div>
</div>
</div>
<div class="section" id="id63">
<h1>インデックス<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id64">
<h2>はじめに<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h2>
<p>インデックスは特定のカラムの値を持つ列を素早く見つけるために使われます。インデックスなしでは、データベースは最初の列から始め関連する列をすべて見つけるためにテーブル全体を読み込まなければなりません。</p>
<p>テーブルが大きくなるほど、時間がかかります。テーブルが問題のカラム用のインデックスを持つ場合、データベースはデータをすべて見ることなくデータの中ほどで位置を素早く決定できます。テーブルが1000の列を持つ場合、これは列を1つづつ読み込むよりも少なくとも100倍以上速いです。</p>
<p>インデックスはinsertとupdateを遅くなるコストがついてきます。しかしながら、一般的に
SQLのwhere条件で使われるフィールドに対して**常に**インデックスを使うべきです。</p>
</div>
<div class="section" id="id65">
<h2>インデックスを追加する<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h2>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a>Doctrine_Record::index``を使用してインデックスを追加できます。インデックスをnameという名前のフィールドに追加するシンプルな例です:</p>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
次のインデックスの例はDoctrineの環境に実際に追加することは想定されていません。これらはインデックス追加用のAPIを示すためだけを意図しています。</div></blockquote>
<p>class IndexTest extends Doctrine_Record { public function</p>
</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;myindex&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>IndexTest: columns: name: string indexes: myindex: fields: [name]</div></blockquote>
<p><a href="#id68"><span class="problematic" id="id69">``</span></a>name``という名前のフィールドにマルチカラムインデックスを追加する例です:</p>
<blockquote>
<div>class MultiColumnIndexTest extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);
$this-&gt;hasColumn(&#8216;code&#8217;, &#8216;string&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;myindex&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を見ることができます:</p>
<blockquote>
<div>MultiColumnIndexTest: columns: name: string code: string indexes:</div></blockquote>
<p>myindex: fields: [name, code]</p>
<p>同じテーブルで複数のインデックスを追加する例です:</p>
<blockquote>
<div>class MultipleIndexTest extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);
$this-&gt;hasColumn(&#8216;code&#8217;, &#8216;string&#8217;); $this-&gt;hasColumn(&#8216;age&#8217;, &#8216;integer&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;myindex&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;ageindex&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>MultipleIndexTest: columns: name: string code: string age: integer</div></blockquote>
<p>indexes: myindex: fields: [name, code] ageindex: fields: [age]</p>
</div>
<div class="section" id="id70">
<h2>インデックスオプション<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h2>
<p>Doctrineは多くのインデックスオプションを提供します。これらの一部はデータベース固有のものです。利用可能なオプションの全リストは次の通りです:</p>
<p>||~ 名前 ||~ 説明 || || <tt class="docutils literal"><span class="pre">sorting</span></tt> ||
文字列の値が&#8217;ASC&#8217;もしくは&#8217;DESC&#8217;の値を取れるか || || <tt class="docutils literal"><span class="pre">length</span></tt> ||
インデックスの長さ(一部のドライバのみサポート)。 || || <tt class="docutils literal"><span class="pre">primary</span></tt>
|| インデックスがプライマリインデックスであるか。 || || <tt class="docutils literal"><span class="pre">type</span></tt>
||
文字列の値で&#8217;unique&#8217;、&#8217;fulltext&#8217;、&#8217;gist&#8217;もしくは&#8217;gin&#8217;が許可されるか||</p>
<p>nameカラムでユニークインデックスを作る方法の例は次の通りです。</p>
<blockquote>
<div>class MultipleIndexTest extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);
$this-&gt;hasColumn(&#8216;code&#8217;, &#8216;string&#8217;); $this-&gt;hasColumn(&#8216;age&#8217;, &#8216;integer&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;myindex&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                    <span class="s1">&#39;sorting&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;ASC&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;length&#39;</span>  <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">),</span>
                    <span class="s1">&#39;code&#39;</span>
                <span class="p">),</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;unique&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。YAMLの詳細は[doc
yaml-schema-files :name]の章で読むことができます:</p>
<blockquote>
<div>MultipleIndexTest: columns: name: string code: string age: integer</div></blockquote>
<p>indexes: myindex: fields: name: sorting: ASC length: 10 code: - type:
unique</p>
</div>
<div class="section" id="id71">
<h2>特別なインデックス<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h2>
<p>Doctrineは多くの特別なインデックスをサポートします。これらにはMysqlのFULLTEXTとPgsqlのGiSTインデックスが含まれます。次の例では&#8217;content&#8217;フィールドに対してMysqlのFULLTEXTインデックスを定義します。</p>
<blockquote>
<div>// models/Article.php</div></blockquote>
<p>class Article extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 255);
$this-&gt;hasColumn(&#8216;content&#8217;, &#8216;string&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">option</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;MyISAM&#39;</span><span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">index</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;fields&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">),</span>
            <span class="s1">&#39;type&#39;</span>   <span class="o">=&gt;</span> <span class="s1">&#39;fulltext&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Article: options: type: MyISAM columns: name: string(255) content:
string indexes: content: fields: [content] type: fulltext</p>
<blockquote>
<div><strong>NOTE</strong>
テーブルの型を``MyISAM``に設定していることに注目してください。これは``fulltext``インデックス型は``MyISAM``でのみサポートされるため``InnoDB``などを使う場合はエラーを受け取るからです。</div></blockquote>
</div>
</div>
<div class="section" id="id72">
<h1>チェック<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h1>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a>Doctrine_Record``の``check()``メソッドを使用することで任意の``CHECK``制約を作成できます。最後の例では価格がディスカウント価格よりも常に高いことを保証するために制約を追加します。</p>
<blockquote>
<div>// models/Product.php</div></blockquote>
<p>class Product extends Doctrine_Record { public function
setTableDefinition() { // ...</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">check</span><span class="p">(</span><span class="s1">&#39;price &gt; discounted_price&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Product: # ... checks: price_check: price &gt; discounted_price</p>
<p>生成されるSQL(pgsql):</p>
<blockquote>
<div>CREATE TABLE product ( id INTEGER, price NUMERIC, discounted_price</div></blockquote>
<p>NUMERIC, PRIMARY KEY(id), CHECK (price &gt;= 0), CHECK (price &lt;= 1000000),
CHECK (price &gt; discounted_price))</p>
<blockquote>
<div><strong>NOTE</strong>
データベースの中には``CHECK``制約をサポートしないものがあります。この場合Doctrineはチェック制約の作成をスキップします。</div></blockquote>
<p>Doctrineバリデータが定義で有効な場合はレコードが保存されるとき価格が常にゼロ以上であることも保証されます。</p>
<p>トランザクションの範囲で保存される価格の中にゼロよりも小さいものがある場合、Doctrineは``Doctrine_Validator_Exception``を投げトランザクションを自動的にロールバックします。</p>
</div>
<div class="section" id="id75">
<h1>テーブルオプション<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h1>
<p>Doctrineはさまざまなテーブルオプションを提供します。すべてのテーブルオプションは``Doctrine_Record::option``関数を通して設定できます。</p>
<p>例えばMySQLを使用しINNODBテーブルを利用したい場合は次のようにできます:</p>
<blockquote>
<div>class MyInnoDbRecord extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">option</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;INNODB&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を見ることができます:</p>
<blockquote>
<div>MyInnoDbRecord: columns: name: string options: type: INNODB</div></blockquote>
<p>次の例では照合順序と文字集合のオプションを設定します:</p>
<blockquote>
<div>class MyCustomOptionRecord extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;);</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">option</span><span class="p">(</span><span class="s1">&#39;collate&#39;</span><span class="p">,</span> <span class="s1">&#39;utf8_unicode_ci&#39;</span><span class="p">);</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">option</span><span class="p">(</span><span class="s1">&#39;charset&#39;</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div>MyCustomOptionRecord: columns: name: string options: collate:</div></blockquote>
<p>utf8_unicode_ci charset: utf8</p>
<p>特定のデータベース(Firebird、MySqlとPostgreSQL)でcharsetオプションを設定しても無意味でDoctrineがデータを適切に返すのには不十分であることがあります。これらのデータベースに対して、データベース接続の``setCharset``関数を使うこともお勧めします:</p>
<blockquote>
<div>$conn = Doctrine_Manager::connection(); $conn-&gt;setCharset(&#8216;utf8&#8217;);</div></blockquote>
</div>
<div class="section" id="id76">
<h1>レコードフィルター<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h1>
<p>Doctrineはモデルを定義するときにレコードフィルターを添付する機能を持ちます。レコードフィルターは無効なモデルのプロパティにアクセスするときに起動されます。ですのでこれらのフィルターの1つを使うことを通してプロパティをモデルに追加することが本質的に可能になります。</p>
<p>フィルターを添付するにはこれをモデル定義の``setUp()``メソッドに追加することだけが必要です:</p>
<blockquote>
<div>class User extends Doctrine_Record { public function</div></blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn(&#8216;username&#8217;, &#8216;string&#8217;, 255);
$this-&gt;hasColumn(&#8216;password&#8217;, &#8216;string&#8217;, 255); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Profile&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
    <span class="p">));</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">unshiftFilter</span><span class="p">(</span><span class="k">new</span> <span class="nx">Doctrine_Record_Filter_Compound</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;Profile&#39;</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>class Profile extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;);
$this-&gt;hasColumn(&#8216;first_name&#8217;, &#8216;string&#8217;, 255);
$this-&gt;hasColumn(&#8216;last_name&#8217;, &#8216;string&#8217;, 255); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Profile&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
    <span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>上記の例のコードによって``User``のインスタンスを使うとき``Profile``リレーションのプロパティに簡単にアクセスできます。次のコードは例です:</p>
<blockquote>
<div>$user = Doctrine_Core::getTable(&#8216;User&#8217;) -&gt;createQuery(&#8216;u&#8217;)</div></blockquote>
<p>-&gt;innerJoin(&#8216;u.Profile p&#8217;) -&gt;where(&#8216;p.username = ?&#8217;, &#8216;jwage&#8217;)
-&gt;fetchOne();</p>
<p>echo $user-&gt;first_name . &#8216; &#8216; . $user-&gt;last_name;</p>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a>first_name``と``last_name``プロパティに問い合わせるときこれらは``$user``インスタンスに存在しないのでこれらは``Profile``リレーションにフォワードされます。これは次の内容を行ったこととまったく同じです:</p>
<blockquote>
<div>echo $user-&gt;Profile-&gt;first_name . &#8216; &#8216; . $user-&gt;Profile-&gt;last_name;</div></blockquote>
<p>独自のレコードフィルターをとても簡単に書くこともできます。必要なことは``Doctrine_Record_Filter``を継承し``filterSet()``と``filterGet()``メソッドを実装するクラスを作ることです。例は次の通りです:</p>
<blockquote>
<div>class MyRecordFilter extends Doctrine_Record_Filter { public function</div></blockquote>
<p>filterSet(Doctrine_Record $record, $name, $value) { //
プロパティをトライしてセットする</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="k">throw</span> <span class="k">new</span> <span class="nx">Doctrine_Record_UnknownPropertyException</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s1">&#39;Unknown record property / related component &quot;%s&quot; on &quot;%s&quot;&#39;</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nb">get_class</span><span class="p">(</span><span class="nv">$record</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">filterGet</span><span class="p">(</span><span class="nx">Doctrine_Record</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// プロパティをトライしてゲットする</span>

    <span class="k">throw</span> <span class="k">new</span> <span class="nx">Doctrine_Record_UnknownPropertyException</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s1">&#39;Unknown record property / related component &quot;%s&quot; on &quot;%s&quot;&#39;</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nb">get_class</span><span class="p">(</span><span class="nv">$record</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>これでフィルターをモデルに追加できます:</p>
<blockquote>
<div>class MyModel extends Doctrine_Record { // ...</div></blockquote>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">unshiftFilter</span><span class="p">(</span><span class="k">new</span> <span class="nx">MyRecordFilter</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<blockquote>
<div><strong>NOTE</strong>
<a href="#id79"><span class="problematic" id="id80">``</span></a>filterSet()``もしくは``filterGet()``がプロパティを見つけられない場合、例外クラスの``Doctrine_Record_UnknownPropertyException``のインスタンスが投げられていることをかならず確認してください。</div></blockquote>
</div>
<div class="section" id="id81">
<h1>遷移的な永続化<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h1>
<p>Doctrineはデータベースとアプリケーションレベルでカスケーディングオペレーションを提供します。このセクションではアプリケーションとデータベースレベルの両方でセットアップする詳細な方法を説明します。</p>
<div class="section" id="id82">
<h2>アプリケーションレベルのカスケード<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h2>
<p>とりわけオブジェクトグラフを扱うとき、個別のオブジェクトの保存と削除はとても退屈です。Doctrineはアプリケーションレベルでオペレーションのカスケード機能を提供します。</p>
<div class="section" id="id83">
<h3>保存カスケード<a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h3>
<p>デフォルトでは``save()``オペレーションは関連オブジェクトに既にカスケードされていることにお気づきかもしれません。</p>
</div>
<div class="section" id="id84">
<h3>削除カスケード<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h3>
<p>Doctrineは2番目のカスケードスタイル:
deleteを提供します。<a href="#id85"><span class="problematic" id="id86">``</span></a>save()``カスケードとは異なり、<a href="#id87"><span class="problematic" id="id88">``</span></a>delete``カスケードは次のコードスニペットのように明示的に有効にする必要があります:</p>
<blockquote>
<div>// models/User.php</div></blockquote>
<p>class User extends BaseUser { // ...</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">parent</span><span class="o">::</span><span class="na">setup</span><span class="p">();</span>

    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Address as Addresses&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cascade&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;delete&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>User: # ... relations: # ... Addresses: class: Address local: id
foreign: user_id cascade: [delete]</p>
<p>アプリケーションレベルで関連オブジェクトにカスケードされるオペレーションを指定するために``cascade``オプションが使われます。</p>
<blockquote>
<div><strong>NOTE</strong>
現在サポートされる値は``delete``のみであることにご注意ください。より多くのオプションは将来のDoctrineのリリースで追加されます。</div></blockquote>
<p>上記の例において、Doctrineは関連する``Address``に``User``の削除をカスケードします。次の説明は``$record-&gt;delete()``を通してレコードを削除する際の一般的な手続きです:</p>
<p><strong>1.</strong>
Doctrineは適用する必要のある削除カスケードが存在するかリレーションを探します。削除カスケードが存在しない場合、3に移動します)。</p>
<p><strong>2.</strong>
指定された削除カスケードを持つそれぞれのリレーションに対して、Doctrineはカスケードのターゲットであるオブジェクトがロードされることを確認します。このことはDoctrineは関連オブジェクトがまだロードされていない場合データベースから関連オブジェクトが取得することを意味します。(例外:
すべてのオブジェクトがロードされていることを確認するために多くの値を持つアソシエーションはデータベースから再取得されます)。それぞれの関連オブジェクトに対して、ステップ1に進みます)。</p>
<p><strong>3.</strong>
Doctrineは参照照合性を維持しながらすべての削除を並べ替え最も効果的な方法で実行します。</p>
<p>この説明から1つのことがすぐに明らかになります:
アプリケーションレベルのカスケードはオブジェクトレベルで行われ、参加しているオブジェクトが利用可能にすることを行うために1つのオブジェクトから別にオブジェクトにオペレーションがカスケードされることを意味します。</p>
<p>このことは重要な意味を示します:</p>
<ul class="simple">
<li>関連の照合順序でたくさんのオブジェクトがあるとき多くの値を持つアソシエーションではアプリケーションレベルの削除カスケードはうまく実行されませんこれらがデータベースから取得される必要があるためで、実際の削除はとても効率的です)。</li>
<li>アプリケーションレベルの削除カスケードはデータベースレベルのカスケードが行うようにオブジェクトのライフサイクルをスキップしません(次の章を参照)。それゆえ登録されたすべてのイベントリスナーと他のコールバックメソッドはアプリケーションレベルのカスケードで適切に実行されます。</li>
</ul>
</div>
</div>
<div class="section" id="id89">
<h2>データベースレベルのカスケード<a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h2>
<p>データベースレベルでカスケードオペレーションはとても効率的にできるものがあります。もっともよい例は削除カスケードです。</p>
<p>次のことを除いて一般的にデータベースレベルの削除カスケードはアプリケーションレベルよりも望ましいです:</p>
<ul class="simple">
<li>データベースがデータベースレベルのカスケードをサポートしない(MySqlでMYISAMテーブルを使うとき)。</li>
<li>オブジェクトライフサイクルをリスニングするリスナーがありこれらを起動させたい。</li>
</ul>
<p>データベースレベルの削除カスケードは外部キー制約に適用されます。それゆえこれらは外部キーを所有するリレーション側で指定されます。上記から例を拾うと、データベースレベルのカスケードの定義は次のようになります:</p>
<blockquote>
<div>// models/Address.php</div></blockquote>
<p>class Address extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;);
$this-&gt;hasColumn(&#8216;address&#8217;, &#8216;string&#8217;, 255); $this-&gt;hasColumn(&#8216;country&#8217;,
&#8216;string&#8217;, 255); $this-&gt;hasColumn(&#8216;city&#8217;, &#8216;string&#8217;, 255);
$this-&gt;hasColumn(&#8216;state&#8217;, &#8216;string&#8217;, 2); $this-&gt;hasColumn(&#8216;postal_code&#8217;,
&#8216;string&#8217;, 25); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;onDelete&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;CASCADE&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を詳しく読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Address: columns: user_id: integer address: string(255) country:
string(255) city: string(255) state: string(2) postal_code: string(25)
relations: User: local: user_id foreign: id onDelete: CASCADE</p>
<p>Doctrineがテーブルを作成するとき``onDelete``オプションは適切なDDL/DMLステートメントに翻訳されます。</p>
<blockquote>
<div><strong>NOTE</strong> <tt class="docutils literal"><span class="pre">'onDelete'</span> <span class="pre">=&gt;</span>
<span class="pre">'CASCADE'``がAddressクラスで指定されることに注目してください。Addressは外部キー(``user_id</span></tt>)を所有するのでデータベースレベルのカスケードは外部キーに適用されます。</div></blockquote>
<p>現在、2つのデータベースレベルのカスケードスタイルは``onDelete``と``onUpdate``に対してのみです。Doctrineがテーブルを作成するとき両方とも外部キーを所有する側で指定されデータベーススキーマに適用されます。</p>
</div>
</div>
<div class="section" id="id90">
<h1>まとめ<a class="headerlink" href="#id90" title="Permalink to this headline">¶</a></h1>
<p>これでDoctrineのモデルを定義するすべての方法を知りました。アプリケーションで[doc
work-with-models モデルと連携する]方法を学ぶ準備ができています。</p>
<p>これはとても大きなトピックなので、少し休憩を取り、マウンテンデューを飲んで[doc
working-with-models 次の章]にすぐに戻ってください。</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">カラム</a><ul>
<li><a class="reference internal" href="#id4">カラムのエイリアス</a></li>
<li><a class="reference internal" href="#id5">デフォルトの値</a></li>
<li><a class="reference internal" href="#id6">データの型</a><ul>
<li><a class="reference internal" href="#id7">はじめに</a></li>
<li><a class="reference internal" href="#id8">型修飾子</a></li>
<li><a class="reference internal" href="#id9">論理型</a></li>
<li><a class="reference internal" href="#id10">整数型</a></li>
<li><a class="reference internal" href="#id11">浮動小数点型</a></li>
<li><a class="reference internal" href="#id12">小数型</a></li>
<li><a class="reference internal" href="#id13">文字列型</a></li>
<li><a class="reference internal" href="#id14">配列</a></li>
<li><a class="reference internal" href="#id15">オブジェクト</a></li>
<li><a class="reference internal" href="#blob">blob</a></li>
<li><a class="reference internal" href="#clob">clob</a></li>
<li><a class="reference internal" href="#timestamp">timestamp</a></li>
<li><a class="reference internal" href="#time">time</a></li>
<li><a class="reference internal" href="#date">date</a></li>
<li><a class="reference internal" href="#enum">enum</a></li>
<li><a class="reference internal" href="#gzip">gzip</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id16">例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">リレーション</a><ul>
<li><a class="reference internal" href="#id18">はじめに</a></li>
<li><a class="reference internal" href="#id29">外部キーのアソシエーション</a><ul>
<li><a class="reference internal" href="#id30">一対一</a></li>
<li><a class="reference internal" href="#id37">一対多と多対一</a></li>
<li><a class="reference internal" href="#id40">ツリー構造</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id41">テーブルのアソシエーションをジョインする</a><ul>
<li><a class="reference internal" href="#id42">多対多</a></li>
<li><a class="reference internal" href="#id51">外部キーの名前</a></li>
<li><a class="reference internal" href="#id52">整合アクション</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id63">インデックス</a><ul>
<li><a class="reference internal" href="#id64">はじめに</a></li>
<li><a class="reference internal" href="#id65">インデックスを追加する</a></li>
<li><a class="reference internal" href="#id70">インデックスオプション</a></li>
<li><a class="reference internal" href="#id71">特別なインデックス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id72">チェック</a></li>
<li><a class="reference internal" href="#id75">テーブルオプション</a></li>
<li><a class="reference internal" href="#id76">レコードフィルター</a></li>
<li><a class="reference internal" href="#id81">遷移的な永続化</a><ul>
<li><a class="reference internal" href="#id82">アプリケーションレベルのカスケード</a><ul>
<li><a class="reference internal" href="#id83">保存カスケード</a></li>
<li><a class="reference internal" href="#id84">削除カスケード</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id89">データベースレベルのカスケード</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id90">まとめ</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="introduction-to-models.html"
                        title="previous chapter">はじめに</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="working-with-models.html"
                        title="next chapter">テストスキーマを定義する</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/ja/manual/defining-models.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="working-with-models.html" title="テストスキーマを定義する"
             >next</a> |</li>
        <li class="right" >
          <a href="introduction-to-models.html" title="はじめに"
             >previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" >Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jonathan Wage and Contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>