

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>はじめに &mdash; Doctrine 1.2.4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Doctrine 1.2.4 documentation" href="../../index.html" />
    <link rel="up" title="Manual" href="index.html" />
    <link rel="next" title="インポートする" href="data-fixtures.html" />
    <link rel="prev" title="はじめに" href="searching.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="data-fixtures.html" title="インポートする"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="searching.html" title="はじめに"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Manual</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>はじめに<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>大抵のユーザーは一度はSQLデータベースで階層データを扱います。階層データの管理はリレーショナルデータベースが意図していることはではないことは疑いの余地はありません。リレーショナルデータベースのテーブルは(XMLのように)階層的ではなく、シンプルでフラットなリストです。階層データは親子のリレーションを持ちリレーショナルデータベーステーブルで自然に表現されません。</p>
<p>我々の目的のために、階層データはデータのコレクションとしてそれぞれのアイテムは単独の親とゼロもしくはそれ以上の子を持ちます(例外はrootアイテムで、これは親を持ちません)。階層データはフォーラムとメーリングリストのスレッド、ビジネス組織のチャート、コンテンツマネジメントのカテゴリ、製品カテゴリを含む様々なデータベースアプリケーションで見つかります。
階層データモデルにおいて、データは木のような構造に編成されます。木構造は親/子のリレーションを使用する情報の反復を可能にします。木構造のデータの説明に関しては、[<a class="reference external" href="http://en.wikipedia.org/wiki/Tree_data_structure">http://en.wikipedia.org/wiki/Tree_data_structure</a>
ここ]を参照してください。</p>
<p>リレーショナルデータベースでツリー構造を管理する方法は主に3つあります:</p>
<ul class="simple">
<li>隣接リストモデル</li>
<li>入れ子集合モデル(もしくは修正版先行順木走査アルゴリズムとも知られる)</li>
<li>経路実体化モデル</li>
</ul>
<p><strong>次のリンク先で詳細な説明があります:</strong></p>
<ul class="simple">
<li>[<a class="reference external" href="http://www.dbazine.com/oracle/or-articles/tropashko4">http://www.dbazine.com/oracle/or-articles/tropashko4</a>
<a class="reference external" href="http://www.dbazine.com/oracle/or-articles/tropashko4">http://www.dbazine.com/oracle/or-articles/tropashko4</a>]</li>
<li>[<a class="reference external" href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html">http://dev.mysql.com/tech-resources/articles/hierarchical-data.html</a>
<a class="reference external" href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html">http://dev.mysql.com/tech-resources/articles/hierarchical-data.html</a>]</li>
</ul>
</div>
<div class="section" id="id2">
<h1>入れ子集合<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id3">
<h2>はじめに<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>入れ子集合はとても早い読み込みアクセス方法を提供する階層データを保存するための解決方法です。しかしながら、入れ子集合の更新はコストがかかります。それゆえこの解決方法は書き込みよりも読み込みがはるかに多い階層に最適です。ウェブの性質から、この方法は大抵のウェブアプリケーションに当てはまります。</p>
<p>入れ子集合の詳細に関しては、次の記事をご覧ください:</p>
<ul class="simple">
<li>[<a class="reference external" href="http://www.sitepoint.com/article/hierarchical-data-database/2">http://www.sitepoint.com/article/hierarchical-data-database/2</a>
<a class="reference external" href="http://www.sitepoint.com/article/hierarchical-data-database/2">http://www.sitepoint.com/article/hierarchical-data-database/2</a>]</li>
<li>[<a class="reference external" href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html">http://dev.mysql.com/tech-resources/articles/hierarchical-data.html</a>
<a class="reference external" href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html">http://dev.mysql.com/tech-resources/articles/hierarchical-data.html</a>]</li>
</ul>
</div>
<div class="section" id="id4">
<h2>セットアップする<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>モデルを入れ子集合としてセットアップするには、モデルの``setUp()``メソッドにコードを追加しなければなりません。例として下記の``Category``モデルを考えてみましょう:</p>
<blockquote>
<div>// models/Category.php</div></blockquote>
<p>class Category extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 255); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">actAs</span><span class="p">(</span><span class="s1">&#39;NestedSet&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Category: actAs: [NestedSet] columns: name: string(255)</p>
<p>Doctrineのテンプレートモデルの詳細情報は[doc behaviors :index
:name]の章で見つかります。これらのテンプレートはモデルに機能を追加します。入れ子集合の例において、3の追加フィールド:
<tt class="docutils literal"><span class="pre">lft</span></tt>、<a href="#id5"><span class="problematic" id="id6">``</span></a>rgt``と``level``が得られます。<a href="#id7"><span class="problematic" id="id8">``</span></a>lft``と``rgt``フィールドを気にする必要はありません。これらは内部で木構造を管理するために使われます。しかしながら``level``フィールドは関係があります。整数の値が木の範囲内のノードの深さを表すからです。レベル0はrootノードを意味します。レベル1はrootノードの直接の子であることを意味します。ノードから``level``フィールドを読み込むことで適切なインデントで木を簡単に表示できます。</p>
<blockquote>
<div><strong>CAUTION</strong>
<tt class="docutils literal"><span class="pre">lft</span></tt>、<tt class="docutils literal"><span class="pre">rgt</span></tt>、<a href="#id9"><span class="problematic" id="id10">``</span></a>level``に値を割り当ててはなりません。これらは入れ子集合で透過的に管理されているからです。</div></blockquote>
</div>
<div class="section" id="id11">
<h2>マルチプルツリー<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>入れ子集合の実装によってテーブルが複数のrootノードを持つ、すなわち同じテーブルで複数の木を持つことが可能になります。</p>
<p>下記の例は``Category``モデルで複数のrootをセットアップして使う方法を示しています:</p>
<blockquote>
<div>// models/Category.php</div></blockquote>
<p>class Category extends Doctrine_Record { // ...</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$options</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;hasManyRoots&#39;</span>     <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
        <span class="s1">&#39;rootColumnName&#39;</span>   <span class="o">=&gt;</span> <span class="s1">&#39;root_id&#39;</span>
    <span class="p">);</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">actAs</span><span class="p">(</span><span class="s1">&#39;NestedSet&#39;</span><span class="p">,</span> <span class="nv">$options</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>Category: actAs: NestedSet: hasManyRoots: true rootColumnName: root_id
columns: name: string(255)</p>
<p><a href="#id12"><span class="problematic" id="id13">``</span></a>rootColumnName``は木を区別するために使われるカラムです。新しいrootノードを作成するとき``root_id``を手動で設定する選択肢があります。さもなければDoctrineが値を割り当てます。</p>
<p>一般的に``root_id``を直接扱う必要はありません。例えば、新しいノードを既存の木に差し込むもしくはツリーの間でノードを移動させるときDoctrineは関連する``root_id``の変更を透過的に処理します。</p>
</div>
<div class="section" id="working-with-trees">
<h2>Working with Trees<a class="headerlink" href="#working-with-trees" title="Permalink to this headline">¶</a></h2>
<p>モデルを入れ子集合としてセットアップが成功したら作業を始めることができます。Doctrineの入れ子集合を実装する作業は2つのクラス:
<a href="#id14"><span class="problematic" id="id15">``</span></a>Doctrine_Tree_NestedSet``と``Doctrine_Node_NestedSet``で行われます。これらのクラスは``Doctrine_Tree_Interface``と``Doctrine_Node_Interface``インターフェイスの実装です。ツリーオブジェクトはテーブルオブジェクトにバインドされノードオブジェクトはレコードオブジェクトにバインドされます。これらの内容は次の通りです:</p>
<p>次のコードを使うことですべてのツリーインターフェイスが利用できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();</p>
<p>次の例では``$category``は``Category``のインスタンスです:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $nodeObject = $category-&gt;getNode();</p>
<p>上記のコードによって全ノードインターフェイスは``$nodeObject``で利用できます。</p>
<p>次のセクションでノードとツリークラスでもっともよく使われるオペレーションを実演するコードスニペットを見ます。</p>
<div class="section" id="root">
<h3>rootノードを作成する<a class="headerlink" href="#root" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $category = new Category(); $category-&gt;name = &#8216;Root Category 1&#8217;;
$category-&gt;save();</p>
<p>$treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();
<tt class="code docutils literal"><span class="pre">treeObject-&gt;createRoot(</span></tt>category);</p>
</div>
<div class="section" id="id16">
<h3>ノードを挿入する<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>次の例では新しい``Category``インスタンスを``Category``のrootの子として追加しています:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $child1 = new Category(); $child1-&gt;name = &#8216;Child Category 1&#8217;;</p>
<p>$child2 = new Category(); $child2-&gt;name = &#8216;Child Category 1&#8217;;</p>
<p><tt class="code docutils literal"><span class="pre">child1-&gt;getNode()-&gt;insertAsLastChildOf(</span></tt>category);
<tt class="code docutils literal"><span class="pre">child2-&gt;getNode()-&gt;insertAsLastChildOf(</span></tt>category);</p>
</div>
<div class="section" id="id17">
<h3>ノードを削除する<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>ツリーからノードを削除するのは簡単でノードオブジェクトで``delete()``メソッドを呼び出します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $category =
Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;findOneByName(&#8216;Child Category 1&#8217;);
$category-&gt;getNode()-&gt;delete();</p>
<blockquote>
<div><strong>CAUTION</strong>
上記のコードは``$category-&gt;delete()``を内部で呼び出しています。レコードではなくノードの上で削除を行うことが重要です。さもなければツリーが壊れることがあります。</div></blockquote>
<p>ノードを削除するとそのノードのすべての子孫も削除されます。ですのでこれらの子孫を削除したくなければノードを削除するまえにどこか別の場所に移動させてください。</p>
</div>
<div class="section" id="id18">
<h3>ノードを移動させる<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>ノードの移動は簡単です。Doctrineはツリーの間でノードを移動させるためのいくつかのメソッドを提供します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $category = new Category(); $category-&gt;name = &#8216;Root Category 2&#8217;;
$category-&gt;save();</p>
<p>$categoryTable = Doctrine_Core::getTable(&#8216;Category&#8217;);</p>
<p>$treeObject = $categoryTable-&gt;getTree(); <tt class="code docutils literal"><span class="pre">treeObject-&gt;createRoot(</span></tt>category);</p>
<p>$childCategory = $categoryTable-&gt;findOneByName(&#8216;Child Category 1&#8217;);
<tt class="code docutils literal"><span class="pre">childCategory-&gt;getNode()-&gt;moveAsLastChildOf(</span></tt>category); ...</p>
<p>ノードを移動させるために利用可能なメソッドのリストは次の通りです:</p>
<ul class="simple">
<li>moveAsLastChildOf($other)</li>
<li>moveAsFirstChildOf($other)</li>
<li>moveAsPrevSiblingOf($other)</li>
<li>moveAsNextSiblingOf($other).</li>
</ul>
<p>メソッドの名前はその名の通りでなけれればなりません。</p>
</div>
<div class="section" id="id19">
<h3>ノードを検査する<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>次のメソッドを使うことでノードとその型を検査することができます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $isLeaf = $category-&gt;getNode()-&gt;isLeaf(); $isRoot =
$category-&gt;getNode()-&gt;isRoot();</p>
<blockquote>
<div><strong>NOTE</strong>
上記のメソッドは葉ノードであるかrootノードであるかによってtrue/falseを返します。</div></blockquote>
</div>
<div class="section" id="id20">
<h3>兄弟の検査と読み込み<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>次のメソッドを使うことでノードが次もしくは前の兄弟を持つのか簡単にチェックできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $hasNextSib = $category-&gt;getNode()-&gt;hasNextSibling(); $hasPrevSib
= $category-&gt;getNode()-&gt;hasPrevSibling();</p>
<p>次のメソッドで存在する次もしくは前の兄弟を読み取ることができます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $nextSib = $category-&gt;getNode()-&gt;getNextSibling(); $prevSib =
$category-&gt;getNode()-&gt;getPrevSibling();</p>
<blockquote>
<div><strong>NOTE</strong>
上記のメソッドは次もしくは前の兄弟が存在しない場合falseを返します。</div></blockquote>
<p>すべての兄弟の配列を読み取るには``getSiblings()``メソッドを使います:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $siblings = $category-&gt;getNode()-&gt;getSiblings();</p>
</div>
<div class="section" id="id21">
<h3>子孫の検査と読み取り<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>次のメソッドを使用することでノードが親もしくは子を持つことをチェックできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $hasChildren = $category-&gt;getNode()-&gt;hasChildren(); $hasParent =
$category-&gt;getNode()-&gt;hasParent();</p>
<p>次のメソッドで最初と最後の子ノードを読み取ることができます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $firstChild = $category-&gt;getNode()-&gt;getFirstChild(); $lastChild =
$category-&gt;getNode()-&gt;getLastChild();</p>
<p>もしくはノードの親を読み取りたい場合:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $parent = $category-&gt;getNode()-&gt;getParent();</p>
<p>次のメソッドを使用してノードの子を取得できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $children = $category-&gt;getNode()-&gt;getChildren();</p>
<blockquote>
<div><strong>CAUTION</strong>
<a href="#id22"><span class="problematic" id="id23">``</span></a>getChildren()``メソッドは直接の子孫のみを返します。すべての子孫を取得したい場合、<a href="#id24"><span class="problematic" id="id25">``</span></a>getDescendants()``メソッドを使います。</div></blockquote>
<p>次のメソッドでノードの祖先もしくは子孫を取得できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $descendants = $category-&gt;getNode()-&gt;getDescendants(); $ancestors
= $category-&gt;getNode()-&gt;getAncestors();</p>
<p>ときに子もしくは子孫の数だけ取得したいことがあります。これは次のメソッドで実現できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $numChildren = $category-&gt;getNode()-&gt;getNumberChildren();
$numDescendants = $category-&gt;getNode()-&gt;getNumberDescendants();</p>
<p><a href="#id26"><span class="problematic" id="id27">``</span></a>getDescendants()``と``getAncestors()``は結果ブランチの``depth``を指定するために使用できるパラメータを受けとります。例えば``getDescendants(1)``は直接の子孫のみを読み取ります(1レベル下の子孫で、これは``getChildren()``と同じです)。同じ流儀で
<a href="#id28"><span class="problematic" id="id29">``</span></a>getAncestors(1)``は直接の祖先(親など)のみを読み取ります。rootノードもしくは特定の祖先までのこのノードのパスを効率的に決定するために``getAncestors()``はとても便利です(すなわちパンくずナビゲーションを構築するため).</p>
</div>
<div class="section" id="id30">
<h3>単純木をレンダリングする<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
次の例では``hasManyRoots``をfalseに設定することを前提とします。下記の例を適切に動作させるためにこのオプションをfalsenに設定しなければなりません。前のセクションでは値をtrueに設定しました。</div></blockquote>
<p>// test.php</p>
</div></blockquote>
<p>// ... $treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();
$tree = $treeObject-&gt;fetchTree();</p>
<p>foreach ($tree as $node) { echo str_repeat(&#8216;&nbsp;&nbsp;&#8217;, $node[&#8216;level&#8217;]) .
$node[&#8216;name&#8217;] . &#8220;&#8221;; }</p>
</div>
</div>
<div class="section" id="id31">
<h2>高度な使い方<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>以前のセクションでは入れ子集合の基本的な使い方を説明しました。このセクションは高度な内容に進みます。</p>
<div class="section" id="id32">
<h3>リレーションでツリーを取得する<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>ソフトウェア開発者に要求している場合すでにこの質問が念頭にあるかもしれません:
&#8220;関連データを持つツリー/ブランチを取得するには？&#8221;. Simple example:
カテゴリのツリーを表示したいが、それぞれのカテゴリの関連データの一部も表示したい場合、そのカテゴリのもっとも詳細な製品の商品を考えてみましょう。以前のセクションのようにツリーを取得しツリーをイテレートする合間にリレーションにアクセスするのは可能ですが、必要のないデータベースクエリをたくさん生み出します。幸いにして、<a href="#id33"><span class="problematic" id="id34">``</span></a>Doctrine_Query``と入れ子集合の実装の柔軟性が手助けしてくれます。入れ子集合の実装は``Doctrine_Query``オブジェクトを使用します。入れ子集合実装の基本クエリオブジェクトにアクセスすることで入れ子集合を使いながら``Doctrine_Query``のフルパワーを解き放つことができます。</p>
<p>最初にツリーデータを読み取るために使うクエリを作りましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;c.name, p.name, m.name&#8217;)
-&gt;from(&#8216;Category c&#8217;) -&gt;leftJoin(&#8216;c.HottestProduct p&#8217;)
-&gt;leftJoin(&#8216;p.Manufacturer m&#8217;);</p>
<p>ツリー用の基本クエリとして上記のクエリを設定する必要があります:</p>
<blockquote>
<div>$treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();</div></blockquote>
<p><tt class="code docutils literal"><span class="pre">treeObject-&gt;setBaseQuery(</span></tt>q); $tree = $treeObject-&gt;fetchTree();</p>
<p>必要なすべてのデータを持つツリーは1つのクエリで取得できます。</p>
<blockquote>
<div><strong>NOTE</strong>
独自の基本クエリを設定しない場合内部で自動的に作成されます。</div></blockquote>
<p>終えたら基本クエリを通常のものに戻すのは良い考えです:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $treeObject-&gt;resetBaseQuery();</p>
<p>さらに踏み込むことができます。[doc improving-performance
:name]の章で述べたように必要なときのみにオブジェクトを取得すべきです。ですので表示(読み込みのみ)目的のみにツリーを表示する場合少し加速するために配列のハイドレーションを使うことができます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;c.name, p.name, m.name&#8217;)
-&gt;from(&#8216;Category c&#8217;) -&gt;leftJoin(&#8216;c.HottestProduct p&#8217;)
-&gt;leftJoin(&#8216;p.Manufacturer m&#8217;)
-&gt;setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);</p>
<p>$treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();
<tt class="code docutils literal"><span class="pre">treeObject-&gt;setBaseQuery(</span></tt>q); $tree = $treeObject-&gt;fetchTree();
<tt class="code docutils literal"><span class="pre">treeObject-&gt;resetBaseQuery();</span> <span class="pre">&lt;/code&gt;</span> <span class="pre">``</span></tt>tree``で素晴らしく構造化された配列が手に入ります。ともかくレコードにアクセスする配列を使う場合、このような変更はコードの他の部分に影響を与えません。クエリを修正するこのメソッドはすべてのノードとツリーメソッド(<tt class="docutils literal"><span class="pre">getAncestors()</span></tt>,
<tt class="docutils literal"><span class="pre">getDescendants()</span></tt>、<tt class="docutils literal"><span class="pre">getChildren()</span></tt>、<tt class="docutils literal"><span class="pre">getParent()</span></tt>)に対して使うことができます。クエリを作り、ツリーオブジェクトの基本クエリとして設定し適切なメソッドとして起動させます。</p>
</div>
</div>
<div class="section" id="id35">
<h2>インデントでレンダリングする<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
<p>下記の例ではすべてのツリーが適切なインデントでレンダリングされます。<a href="#id36"><span class="problematic" id="id37">``</span></a>fetchRoots()``メソッドを使用してrootを読み取り``fetchTree()``メソッドを使用して個別のツリーを読み取ることができます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $treeObject = Doctrine_Core::getTable(&#8216;Category&#8217;)-&gt;getTree();
$rootColumnName = $treeObject-&gt;getAttribute(&#8216;rootColumnName&#8217;);</p>
<p>foreach ($treeObject-&gt;fetchRoots() as $root) { $options = array(
&#8216;root_id&#8217; =&gt; <tt class="code docutils literal"><span class="pre">root-&gt;</span></tt>rootColumnName );
foreach(<tt class="code docutils literal"><span class="pre">treeObject-&gt;fetchTree(</span></tt>options) as $node) { echo
str_repeat(&#8216; &#8216;, $node[&#8216;level&#8217;]) . $node[&#8216;name&#8217;] . &#8220;&#8221;; } }</p>
<p>すべての作業を終えた後で上記のコードは次のようにレンダリングされます:</p>
<blockquote>
<div>$ php test.php Root Category 1 Root Category 2 Child Category 1</div></blockquote>
<p>===
まとめ
===</p>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a>NestedSet``ビヘイビアに関するすべての内容と階層データを管理する方法を学んだので[doc
data-fixtures
:name]を学ぶ準備ができています。データフィクスチャはアプリケーションの小さなテストデータをロードするための偉大なツールでユニットテストと機能テストを行うもしくは初期データをアプリケーションに投入するために使われます。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">はじめに</a></li>
<li><a class="reference internal" href="#id2">入れ子集合</a><ul>
<li><a class="reference internal" href="#id3">はじめに</a></li>
<li><a class="reference internal" href="#id4">セットアップする</a></li>
<li><a class="reference internal" href="#id11">マルチプルツリー</a></li>
<li><a class="reference internal" href="#working-with-trees">Working with Trees</a><ul>
<li><a class="reference internal" href="#root">rootノードを作成する</a></li>
<li><a class="reference internal" href="#id16">ノードを挿入する</a></li>
<li><a class="reference internal" href="#id17">ノードを削除する</a></li>
<li><a class="reference internal" href="#id18">ノードを移動させる</a></li>
<li><a class="reference internal" href="#id19">ノードを検査する</a></li>
<li><a class="reference internal" href="#id20">兄弟の検査と読み込み</a></li>
<li><a class="reference internal" href="#id21">子孫の検査と読み取り</a></li>
<li><a class="reference internal" href="#id30">単純木をレンダリングする</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id31">高度な使い方</a><ul>
<li><a class="reference internal" href="#id32">リレーションでツリーを取得する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id35">インデントでレンダリングする</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="searching.html"
                        title="previous chapter">はじめに</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="data-fixtures.html"
                        title="next chapter">インポートする</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/ja/manual/hierarchical-data.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="data-fixtures.html" title="インポートする"
             >next</a> |</li>
        <li class="right" >
          <a href="searching.html" title="はじめに"
             >previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" >Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jonathan Wage and Contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>