

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>テストスキーマを定義する &mdash; Doctrine 1.2.4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Doctrine 1.2.4 documentation" href="../../index.html" />
    <link rel="up" title="Manual" href="index.html" />
    <link rel="next" title="はじめに" href="dql-doctrine-query-language.html" />
    <link rel="prev" title="カラム" href="defining-models.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="dql-doctrine-query-language.html" title="はじめに"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="defining-models.html" title="カラム"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Manual</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>テストスキーマを定義する<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><blockquote>
<div><strong>NOTE</strong>
以前の章からの既存のスキーマ情報をモデルを削除しておいてください。</div></blockquote>
<p>$ rm schema.yml $ touch schema.yml $ rm -rf models/*</p>
</div></blockquote>
<p>次のいくつかの例に対して次のスキーマを使います:</p>
<blockquote>
<div>// models/User.php</div></blockquote>
<p>class User extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;username&#8217;, &#8216;string&#8217;, 255,
array( &#8216;type&#8217; =&gt; &#8216;string&#8217;, &#8216;length&#8217; =&gt; &#8216;255&#8217; ) );</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;255&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Group as Groups&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;refClass&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;UserGroup&#39;</span><span class="p">,</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;group_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;Email&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;Phonenumber as Phonenumbers&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>// models/Email.php</p>
<p>class Email extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;, null,
array( &#8216;type&#8217; =&gt; &#8216;integer&#8217; ) );</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;255&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>// models/Phonenumber.php</p>
<p>class Phonenumber extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;, null,
array( &#8216;type&#8217; =&gt; &#8216;integer&#8217; ) );</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;phonenumber&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;255&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;primary_num&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasOne</span><span class="p">(</span><span class="s1">&#39;User&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>// models/Group.php</p>
<p>class Group extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;setTableName(&#8216;groups&#8217;);
$this-&gt;hasColumn(&#8216;name&#8217;, &#8216;string&#8217;, 255, array( &#8216;type&#8217; =&gt; &#8216;string&#8217;,
&#8216;length&#8217; =&gt; &#8216;255&#8217; ) ); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasMany</span><span class="p">(</span><span class="s1">&#39;User as Users&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;refClass&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;UserGroup&#39;</span><span class="p">,</span>
            <span class="s1">&#39;local&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;group_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;foreign&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;user_id&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>// models/UserGroup.php</p>
<p>class UserGroup extends Doctrine_Record { public function
setTableDefinition() { $this-&gt;hasColumn(&#8216;user_id&#8217;, &#8216;integer&#8217;, null,
array( &#8216;type&#8217; =&gt; &#8216;integer&#8217;, &#8216;primary&#8217; =&gt; true ) );</p>
<div class="highlight-php"><div class="highlight"><pre>    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasColumn</span><span class="p">(</span><span class="s1">&#39;group_id&#39;</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;primary&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote>
<div># schema.yml</div></blockquote>
<p>User: columns: username: string(255) password: string(255) relations:
Groups: class: Group local: user_id foreign: group_id refClass:
UserGroup foreignAlias: Users</p>
<p>Email: columns: user_id: integer address: string(255) relations: User:
foreignType: one</p>
<p>Phonenumber: columns: user_id: integer phonenumber: string(255)
primary_num: boolean relations: User: foreignAlias: Phonenumbers</p>
<p>Group: tableName: groups columns: name: string(255)</p>
<p>UserGroup: columns: user_id: type: integer primary: true group_id:
type: integer primary: true</p>
<p>スキーマを定義したので以前の章で利便性のために作成した``generate.php``スクリプトを実行してデータベースをインスタンス化できます。</p>
<blockquote>
<div>$ php generate.php</div></blockquote>
</div>
<div class="section" id="id2">
<h1>リレーションを扱う<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id3">
<h2>関連レコードを作成する<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Doctrineで関連レコードにアクセスするのは簡単です:
レコードプロパティに関してまったく同じゲッターとセッターを使うことができます。</p>
<p>3つの方法はどれでも使えますが、配列のポータビリティを目的にするなら最後の方法がお勧めです。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = new User(); $user[&#8216;username&#8217;] = &#8216;jwage&#8217;;
$user-[&#8216;password&#8217;] = &#8216;changeme&#8217;;</p>
<p>$email = $user-&gt;Email;</p>
<p>$email = $user-&gt;get(&#8216;Email&#8217;);</p>
<p>$email = $user[&#8216;Email&#8217;];</p>
<p>存在しない一対一の関連レコードにアクセスするとき、Doctrineは自動的にオブジェクトを作成します。That
is why the above</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Email-&gt;address = <a class="reference external" href="mailto:'jonwage&#37;&#52;&#48;gmail&#46;com">'jonwage<span>&#64;</span>gmail<span>&#46;</span>com</a>&#8216;; $user-&gt;save();</p>
<p>一対多の関連レコードにアクセスするとき、Doctrineは関連コンポーネント用の``Doctrine_Collection``を作成します。リレーションが一対多である``users``と``phonenumbers``を考えてみましょう。上記で示されるように``phonenumbers``を簡単に追加できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Phonenumbers[]-&gt;phonenumber = &#8216;123 123&#8217;;
$user-&gt;Phonenumbers[]-&gt;phonenumber = &#8216;456 123&#8217;;
$user-&gt;Phonenumbers[]-&gt;phonenumber = &#8216;123 777&#8217;;</p>
<p>ユーザーと関連の電話番号を簡単に保存できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;save();</p>
<p>2つの関連コンポーネントの間でリンクを簡単に作る別の方法は``Doctrine_Record::link()``を使うことです。既存の2つのレコードをお互いに関連づける(もしくはリンクする)ことはよくあります。この場合、関わるレコードクラスの間で定義されたリレーションがある場合、関連レコードの識別子だけが必要です:</p>
<p>新しい
<a href="#id4"><span class="problematic" id="id5">``</span></a>Phonenumber``オブジェクトを作成し新しい電話番号の識別子を追跡しましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $phoneIds = array();</p>
<p>$phone1 = new Phonenumber(); $phone1[&#8216;phonenumber&#8217;] = &#8216;555 202 7890&#8217;;
$phone1-&gt;save();</p>
<p>$phoneIds[] = $phone1[&#8216;id&#8217;];</p>
<p>$phone2 = new Phonenumber(); $phone2[&#8216;phonenumber&#8217;] = &#8216;555 100 7890&#8217;;
$phone2-&gt;save();</p>
<p>$phoneIds[] = $phone2[&#8216;id&#8217;];</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a>User``レコード用に存在するので電話番号をユーザーにリンクしましょう。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>$user = new User(); $user[&#8216;username&#8217;] = &#8216;jwage&#8217;; $user[&#8216;password&#8217;] =
&#8216;changeme&#8217;; $user-&gt;save();</p>
<p>$user-&gt;link(&#8216;Phonenumbers&#8217;, $phoneIds);</p>
<p><a href="#id8"><span class="problematic" id="id9">``</span></a>User``レコードクラスへのリレーションが``Phonenumber``レコードクラスに対して定義された場合、次のようにもできます:</p>
<p>最初に連携するユーザーを作ります:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = new User(); $user[&#8216;username&#8217;] = &#8216;jwage&#8217;;
$user[&#8216;password&#8217;] = &#8216;changeme&#8217;; $user-&gt;save();</p>
<p>新しい``Phonenumber``インスタンスを作成します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $phone1 = new Phonenumber(); $phone1[&#8216;phonenumber&#8217;] = &#8216;555 202
7890&#8217;; $phone1-&gt;save();</p>
<p><a href="#id10"><span class="problematic" id="id11">``</span></a>User``を``Phonenumber``にリンクできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... <tt class="code docutils literal"><span class="pre">phone1-&gt;link('User',</span> <span class="pre">array(</span></tt>user[&#8216;id&#8217;]));</p>
<p>別の電話番号を作成できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $phone2 = new Phonenumber(); $phone2[&#8216;phonenumber&#8217;] = &#8216;555 100
7890&#8217;;</p>
<p>この``Phonenumber``も``User``にリンクしましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... <tt class="code docutils literal"><span class="pre">phone2-&gt;link('User',</span> <span class="pre">array(</span></tt>user[&#8216;id&#8217;]));</p>
</div>
<div class="section" id="id12">
<h2>関連レコードを読み取る<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>前の節とまったく同じな``Doctrine_Record``メソッドで関連レコードを読み取ることができます。既にロードされていない関連コンポーネントにアクセスするときDoctrineが取得に1つのSELECT文を使用することに注意してください。次の例では3つの``SQL
SELECT``が実行されます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = Doctrine_Core::getTable(&#8216;User&#8217;)-&gt;find(1);</p>
<p>echo $user-&gt;Email[&#8216;address&#8217;];</p>
<p>echo $user-&gt;Phonenumber[0]-&gt;phonenumber;</p>
<p>これをもっと効率的に行うにはDQLを使います。次の例では関連コンポーネントの読み取りに1つのSQLクエリのみを使用します。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Email e&#8217;) -&gt;leftJoin(&#8216;u.Phonenumber p&#8217;) -&gt;where(&#8216;u.id =
?&#8217;, 1);</p>
<p>$user = $q-&gt;fetchOne();</p>
<p>echo $user-&gt;Email[&#8216;address&#8217;];</p>
<p>echo $user-&gt;Phonenumber[0][&#8216;phonenumber&#8217;];</p>
</div>
<div class="section" id="id13">
<h2>関連レコードを更新する<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>それぞれの関連オブジェクト/コレクションに対してsaveを個別に呼び出すもしくは他のオブジェクトを所有するオブジェクトでsave()を呼び出すことで関連レコードを更新できます。すべての追加オブジェクトを保存する``Doctrine_Connection::flush``を呼び出すこともできます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Email[&#8216;address&#8217;] = <a class="reference external" href="mailto:'koskenkorva&#37;&#52;&#48;drinkmore&#46;info">'koskenkorva<span>&#64;</span>drinkmore<span>&#46;</span>info</a>&#8216;;</p>
<p>$user-&gt;Phonenumber[0][&#8216;phonenumber&#8217;] = &#8216;123123&#8217;;</p>
<p>$user-&gt;save();</p>
<blockquote>
<div><strong>NOTE</strong>
上記の例では``$user-&gt;save()``を呼び出すことで``email``と``phonenumber``が保存されます。</div></blockquote>
</div>
<div class="section" id="id14">
<h2>関連レコードをクリアする<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>オブジェクトから関連レコードリファレンスをクリアすることができます。これはこれらのオブジェクトが関連しているという事実を変更することはなく、また保存するのであればデータベースでこれを変更することはありません。これはPHPの1つのオブジェクトの参照を別のものにクリアするだけです。</p>
<p>次のコードを実行することですべてのリファレンスをクリアできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;clearRelated();</p>
<p>もしくは特定のリレーションシップをクリアすることもできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;clearRelated(&#8216;Email&#8217;);</p>
<p>これは次のようなことをしたい場合に便利です:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... if ($user-&gt;Email-&gt;exists()) { // ユーザーがメールを持つ } else {
// ユーザーがメールを持たない }</p>
<p>$user-&gt;clearRelated(&#8216;Email&#8217;);</p>
<p><a href="#id15"><span class="problematic" id="id16">``</span></a>Email``オブジェクトが存在しない場合Doctrineが新しい``Email``オブジェクトを自動的に作成するので、あたかも``$user-&gt;save()``を呼び出し``User``の空白の``Email``レコードを保存しないように、この参照をクリアする必要があります。</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a>relatedExists()``メソッドを使うことで上記のシナリオを簡略化できます。これで上記のチェックはより短いコードになり後で不必要な参照をクリアすることにわずらわずに済みます。</p>
<blockquote>
<div>if ($user-&gt;relatedExists(&#8216;Email&#8217;)) { // ユーザーがメールを持つ } else {</div></blockquote>
<p>// ユーザーがメールを持たない }</p>
</div>
<div class="section" id="id19">
<h2>関連レコードを削除する<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>レコードもしくはコレクション上で``delete()``を呼び出すことで関連レコードを個別に削除できます。</p>
<p>個別の関連レコードを削除できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Email-&gt;delete();</p>
<p>レコードのコレクションの範囲から個別のレコードを削除できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Phonenumber[3]-&gt;delete();</p>
<p>望むのであればコレクション全体を削除できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;Phonenumbers-&gt;delete();</p>
<p>もしくはユーザー全体とすべての関連オブジェクトを削除できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;delete();</p>
<p>典型的なウェブアプリケーションでは削除される関連オブジェクトの主キーはフォームからやってきます。この場合関連レコードの最も効率的な削除はDQLのDELETEステートメントを使用することです。リレーションが一対多である``Users``と``Phonenumbers``を再度考えてみましょう。与えられたユーザーidに対して``Phonenumbers``を削除することは次のように実現できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;delete(&#8216;Phonenumber&#8217;)
-&gt;addWhere(&#8216;user_id = ?&#8217;, 5) -&gt;whereIn(&#8216;id&#8217;, array(1, 2, 3));</p>
<p>$numDeleted = $q-&gt;execute();</p>
<p>ときに``Phonenumber``レコードを削除したくないが外部キーをnullに設定することでリレーションのリンクを解除したいことがあります。もちろんこれはDQLを使えば実現できますが最もエレガントな方法は``Doctrine_Record::unlink()``を使う方法です。</p>
<blockquote>
<div><strong>NOTE</strong>
<a href="#id20"><span class="problematic" id="id21">``</span></a>unlink()``メソッドが非常にスマートであることに留意してください。このメソッドは関連する``Phonenumbers``用の外部キーをnullにする設定するだけでなく{User``オブジェクトから``Phonenumber``のすべての参照も削除します。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">User``が3つの``Phonenumbers``(識別子は1、2と3)を持つことを考えましょう。``Phonenumbers</span></tt>
1と3のリンク解除は次のように実現できます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;unlink(&#8216;Phonenumber&#8217;, array(1, 3));</p>
<p>echo $user-&gt;Phonenumbers-&gt;count(); // 1</p>
</div>
<div class="section" id="id22">
<h2>関連レコードに取り組む<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id23">
<h3>リレーションの存在をテストする<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<p>下記の例ではリレーションがまだインスタンス化されないのでfalseが返されます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... <tt class="code docutils literal"><span class="pre">user</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">User();</span> <span class="pre">if</span> <span class="pre">(isset(</span></tt>user-&gt;Email)) { // ... }</p>
<p>次の例では``Email``リレーションをインスタンス化したのでtrueが返されます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $obj-&gt;Email = new Email();</p>
<p>if(isset($obj-&gt;Email)) { // ... }</p>
</div>
</div>
</div>
<div class="section" id="id24">
<h1>多対多のリレーション<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><strong>CAUTION</strong>
Doctrineは多対多のリレーションが双方向であることを求めます。例:
<a href="#id25"><span class="problematic" id="id26">``</span></a>User``は複数の``Groups``を持たなければならず``Group``は複数の``User``を持たなければならない</div></blockquote>
<div class="section" id="id27">
<h2>新しいレコードを作成する<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<p><a href="#id28"><span class="problematic" id="id29">``</span></a>User``と``Group``の2つのクラスを考えてみましょう。これらはGroupUserアソシエーションクラスを通してリンクされます。一時的な(新しい)レコードを扱うときに``User``と``Groups``の組を追加するための最速の方法は次の通りです:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = new User(); $user-&gt;username = &#8216;Some User&#8217;;
$user-&gt;Groups[0]-&gt;username = &#8216;Some Group&#8217;; $user-&gt;Groups[1]-&gt;username =
&#8216;Some Other Group&#8217;; $user-&gt;save();</p>
<p>しかしながら実際の世界のシナリオではユーザーを追加したい既存のグループがあることはよくあります、これを行う最も効率的な方法は次の通りです:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $groupUser = new GroupUser(); $groupUser-&gt;user_id = $userId;
$groupUser-&gt;group_id = $groupId; $groupUser-&gt;save();</p>
</div>
<div class="section" id="id30">
<h2>リンクを削除する<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>多対多の関連レコード間のリンクを削除する正しい方法はDQL
DELETEステートメントを使うことです。DQL
DELETEを利用する際に便利で推奨される方法はQuery APIを通して行われます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;delete(&#8216;UserGroup&#8217;)
-&gt;addWhere(&#8216;user_id = ?&#8217;, 5) -&gt;whereIn(&#8216;group_id&#8217;, array(1, 2));</p>
<p>$deleted = $q-&gt;execute();</p>
<p>関連オブジェクトの間のリレーションを``unlink``する別の方法は``Doctrine_Record::unlink``メソッドを通したものです。しかしながら、こｎメソッドは最初にデータベースにクエリを行うので親モデルが既に存在しない限りこのメソッドは避けるべきです。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = Doctrine_Core::getTable(&#8216;User&#8217;)-&gt;find(5);
$user-&gt;unlink(&#8216;Group&#8217;, array(1, 2)); $user-&gt;save();</p>
<p>2番目の引数を省略することで``Group``へのすべてのリレーションのリンクを解除することもできます:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;unlink(&#8216;Group&#8217;);</p>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a>User``と``Group``の間のリンクを削除する明確で便利な方法が次であるとしても、これを行うべきでは*ありません*:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = Doctrine_Core::getTable(&#8216;User&#8217;)-&gt;find(5);
$user-&gt;GroupUser-&gt;remove(0)-&gt;remove(1); $user-&gt;save();</p>
<p>この方法は``$user-&gt;GroupUser``への呼び出しは与えられた``User``に対するすべての``Group``リンクをロードしているからです。<a href="#id33"><span class="problematic" id="id34">``</span></a>User``が多くの``Groups``に所属している場合この方法が時間のかかるタスクになる可能性があります。ユーザーがわずかな``groups``に所属する場合でも、これが不要なSELECTステートメントを実行します。</p>
</div>
</div>
<div class="section" id="id35">
<h1>オブジェクトをフェッチする<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h1>
<p>通常データベースからデータをフェッチするとき次のフレーズが実行されます:</p>
<p>オブジェクトフェッチの観点からこれら2つのフェーズを&#8217;フェッチ&#8217;フェーズにします。Doctrineにはハイドレーションフェーズと呼ばれる別のフェーズもあります。ハイドレーションフェーズは構造化あれた配列／オブジェクトをフェッチするときに起こります。Doctrineで明示的に指定されないものはハイドレイトされます。</p>
<p>リレーションシップが1対多である``Users``と``Phonenumbers``がある場合を考えてみましょう。次のプレーンなSQLクエリを考えましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $sql = &#8216;SELECT u.id, u.username, p.phonenumber FROM user u LEFT
JOIN phonenumber p ON u.id = p.user_id&#8217;; $results =
<tt class="code docutils literal"><span class="pre">conn-&gt;getDbh()-&gt;fetchAll(</span></tt>sql);</p>
<p>この種の一対多のJOINに慣れている場合
基本の結果セットをコンストラクトする方法に親しみやすいかもしれません。ユーザーが複数の電話番号を持つときは結果セットに重複データが存在します。結果セットは次のようになります:</p>
<p>||~ index ||~ <tt class="docutils literal"><span class="pre">u.id</span></tt> ||~ <tt class="docutils literal"><span class="pre">u.username</span></tt> ||~ <tt class="docutils literal"><span class="pre">p.phonenumber</span></tt>
|| || 0 || 1 || Jack Daniels || 123 123 || || 1 || 1
|| Jack Daniels || 456 456 || || 2 || 2 || John Beer ||
111 111 || || 3 || 3 || John Smith || 222 222 || || 4 ||
3 || John Smith || 333 333 || || 5 || 3 || John Smith ||
444 444 ||</p>
<p>Jack Danielsが2つの``Phonenumbers``を持ち、John
Beerは1つ持つのに対してJohn
Smithは3つ持ちます。この結果セットがいかにぶかっこうなことにお気づきのことでしょう。あちらこちらで重複データのチェックが必要なのでイテレートするのは難しいです。</p>
<p>Doctrineのハイドレーションはすべての重複データを削除します。これは次のようなほかの多くのことも実行します:</p>
<p>SQLクエリに同等なDQLを考えてみましょう:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.id, u.username,
p.phonenumber&#8217;) -&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Phonenumbers p&#8217;);</p>
<p>$results = $q-&gt;execute(array(), Doctrine_Core::HYDRATE_ARRAY);</p>
<p>print_r($results);</p>
<p>ハイドレイトされた配列の構造は次の通りです:</p>
<blockquote>
<div>$ php test.php Array ( [0] =&gt; Array ( [id] =&gt; 1 [username] =&gt;</div></blockquote>
<p>[Phonenumbers] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 1 [phonenumber] =&gt; 123
123 )</p>
<div class="highlight-php"><div class="highlight"><pre>                <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="k">Array</span>
                    <span class="p">(</span>
                        <span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">2</span>
                        <span class="p">[</span><span class="nx">phonenumber</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">456</span> <span class="mi">123</span>
                    <span class="p">)</span>

                <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="k">Array</span>
                    <span class="p">(</span>
                        <span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">3</span>
                        <span class="p">[</span><span class="nx">phonenumber</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">123</span> <span class="mi">777</span>
                    <span class="p">)</span>

            <span class="p">)</span>

    <span class="p">)</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>)</p>
<p>この構造はオブジェクト(レコード)のハイドレーションにも適用されます。これはDoctrineのデフォルトのハイドレーションモードです。唯一の違いは個別の要素が``Doctrine_Record``オブジェクトと``Doctrine_Collection``オブジェクトに変換される配列として表現されることです。オブジェクトの配列を扱うとき、次のことができます:</p>
<p>アクセスオンリーの目的でデータが必要なときはつねに配列ハイドレーションを使うべきである一方でフェッチされたデータを変更する必要があるときはレコードハイドレーションを使うべきです。</p>
<p>ハイドレーションアルゴリズムのコンスタントなO(n)パフォーマンスはスマートアイデンフィファーキャッシングソリューションによって保証されます。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">データベースの1つのレコードで複数のオブジェクトが存在しないことを確認するためにDoctrineは内部でアイデンティティマップを使います。オブジェクトをフェッチしプロパティの一部を修正する場合、後で同じオブジェクトを取得すれば、修正されたプロパティはデフォルトでオーバーライドされます。<a href="#id36"><span class="problematic" id="id37">``</span></a>ATTR_HYDRATE_OVERWRITE``属性を``false``に変更することでこのふるまいを変更することができます。</p>
</div>
<div class="section" id="id38">
<h2>サンプルのクエリ<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h2>
<p><strong>リレーションに対してレコードの数をカウントする:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.*, COUNT(DISTINCT
p.id) AS num_phonenumbers&#8217;) -&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Phonenumbers
p&#8217;) -&gt;groupBy(&#8216;u.id&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p>echo $users[0][&#8216;Phonenumbers&#8217;][0][&#8216;num_phonenumbers&#8217;];</p>
<p><strong>ユーザーとユーザーが所属するグループを読み取る:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Groups g&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p>foreach ($users[0][&#8216;Groups&#8217;] as $group) { echo $group[&#8216;name&#8217;]; }</p>
<p><strong>1つのパラメータの値を持つシンプルなWHERE:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;where(&#8216;u.username = ?&#8217;, &#8216;jwage&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>複数のパラメータの値を持つマルチプルWHERE:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Phonenumbers p&#8217;) -&gt;where(&#8216;u.username = ? AND p.id = ?&#8217;,
array(1, 1));</p>
<p>$users = $q-&gt;fetchArray();</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<blockquote>
<div>オプションとして既存のwhere部分に追加するために``andWhere()``メソッドを使うこともできます。</div></blockquote>
<p class="last">// test.php</p>
</div>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Phonenumbers p&#8217;) -&gt;where(&#8216;u.username = ?&#8217;, 1)
-&gt;andWhere(&#8216;p.id = ?&#8217;, 1);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>``whereIn()``コンビニエンスメソッドを使用する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;) -&gt;whereIn(&#8216;u.id&#8217;,
array(1, 2, 3));</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>次のコードは上記と同じ:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;) -&gt;where(&#8216;u.id IN
(1, 2, 3)&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>WHEREでDBMS関数を使う:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $userEncryptedKey = &#8216;a157a558ac00449c92294c7fab684ae0&#8217;; $q =
Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;where(&#8220;MD5(CONCAT(u.username, &#8216;secret_key&#8217;)) = ?&#8221;,
$userEncryptedKey);</p>
<p>$user = $q-&gt;fetchOne();</p>
<p>$q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;where(&#8216;LOWER(u.username) = LOWER(?)&#8217;, &#8216;jwage&#8217;);</p>
<p>$user = $q-&gt;fetchOne();</p>
<p><strong>集約関数を使用して結果セットを制限する。1つ以上の電話番号を持つユーザーに制限する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.*, COUNT(DISTINCT
p.id) AS num_phonenumbers&#8217;) -&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Phonenumbers
p&#8217;) -&gt;having(&#8216;num_phonenumbers &gt; 1&#8217;) -&gt;groupBy(&#8216;u.id&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>WITHを使用して最初の電話番号のみをJOINする:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Phonenumbers p WITH p.primary_num = ?&#8217;, true);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>最適化用に特定のカラムを選択する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.username, p.phone&#8217;)
-&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Phonenumbers p&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>1つの``Phonenumber``カラムのみ以外のすべての``User``カラムを選択するためにワイルドカードを使用する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.*, p.phonenumber&#8217;)
-&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Phonenumbers p&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>シンプルなWHEREでDQLのdeleteを実行する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;delete(&#8216;Phonenumber&#8217;)
-&gt;addWhere(&#8216;user_id = 5&#8217;);</p>
<p>$deleted = $q-&gt;execute();</p>
<p><strong>1つのカラムに対してシンプルなDQLのupdateを実行する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;update(&#8216;User u&#8217;)
-&gt;set(&#8216;u.is_active&#8217;, &#8216;?&#8217;, true) -&gt;where(&#8216;u.id = ?&#8217;, 1);</p>
<p>$updated = $q-&gt;execute();</p>
<p><strong>DBMSの関数でDQL updateを実行する。すべてのユーザー名を小文字にする:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;update(&#8216;User u&#8217;)
-&gt;set(&#8216;u.username&#8217;, &#8216;LOWER(u.username)&#8217;);</p>
<p>$updated = $q-&gt;execute();</p>
<p><strong>レコードを検索するためにMySQLのLIKEを使用する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;where(&#8216;u.username LIKE ?&#8217;, &#8216;%jwage%&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>レコードエントリのキーが割り当てたカラムの名前であるデータをハイドレイトするためにINDEXBYキーワードを使用する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u INDEXBY
u.username&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>jwageのユーザー名を持つユーザーを表示できます:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... print_r($users[&#8216;jwage&#8217;]);</p>
<p><strong>位置パラメータを使用する</strong></p>
<blockquote>
<div>$q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;) -&gt;where(&#8216;u.username =</div></blockquote>
<p>?&#8217;, array(&#8216;Arnold&#8217;));</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>名前付きパラメータを使用する</strong></p>
<blockquote>
<div>$q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;) -&gt;where(&#8216;u.username =</div></blockquote>
<p>:username&#8217;, array(&#8216;:username&#8217; =&gt; &#8216;Arnold&#8217;));</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>WHEREでサブクエリを使用する。Group
2という名前のグループに存在しないユーザーを見つける:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;) -&gt;where(&#8216;u.id NOT
IN (SELECT u.id FROM User u2 INNER JOIN u2.Groups g WHERE g.name = ?)&#8217;,
&#8216;Group 2&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">サブクエリなしでこれを実現できます。下記の2つの例は上記の例と同じ結果が得られます。</p>
</div>
<p><strong>グループを持つユーザーを読み取るためにINNER JOINを使用する</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;innerJoin(&#8216;u.Groups g WITH g.name != ?&#8217;, &#8216;Group 2&#8217;)</p>
<p>$users = $q-&gt;fetchArray();</p>
<p><strong>グループを持つユーザーを読み取るためにWHERE条件を使用する</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;)
-&gt;leftJoin(&#8216;u.Groups g&#8217;) -&gt;where(&#8216;g.name != ?&#8217;, &#8216;Group 2&#8217;);</p>
<p>$users = $q-&gt;fetchArray();</p>
<p>Doctrineはクエリを実行してデータを読み取るための多くの方法を持ちます。下記のコードはクエリを実行する異なるすべての方法の例です:</p>
<p><strong>最初にテストするサンプルクエリを作成する:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;from(&#8216;User u&#8217;);</p>
<p><strong>``fetchArray()``メソッドで配列のハイドレーションを実行できます:</strong></p>
<blockquote>
<div>$users = $q-&gt;fetchArray();</div></blockquote>
<p><strong>``execute()``メソッドの2番目の引数でハイドレーションメソッドを指定することでも配列のハイドレーションを利用できます:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $users = $q-&gt;execute(array(), Doctrine::HYDRATE_ARRAY)</p>
<p><strong>``setHydrationMethod()``メソッドを利用することでもハイドレーションメソッドを指定できます:</strong></p>
<blockquote>
<div>$users = $q-&gt;setHydrationMode(Doctrine::HYDRATE_ARRAY)-&gt;execute(); //</div></blockquote>
<p>So is this</p>
<p><strong>ときにはハイドレーションを完全に回避してPDOが返す生のデータが欲しいことがあります:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $users = $q-&gt;execute(array(), Doctrine::HYDRATE_NONE);</p>
<p><strong>クエリから1つのレコードだけを取得したい場合:</strong></p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = $q-&gt;fetchOne();</p>
<p>// Fetch all and get the first from collection $user =
$q-&gt;execute()-&gt;getFirst();</p>
</div>
<div class="section" id="id39">
<h2>フィールドの遅延ロード<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<p>データベースからロードされるすべてのフィールドを持たないオブジェクトを取得するときこのオブジェクトの状態はプロキシ(proxy)と呼ばれます。プロキシオブジェクトはまたロードされていないフィールドを遅延ロードできます。</p>
<p>次の例では直接ロードされた``username``フィールドを持つすべてのUsersを取得します。それからpasswordフィールドを遅延ロードします:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.username&#8217;)
-&gt;from(&#8216;User u&#8217;) -&gt;where(&#8216;u.id = ?&#8217;, 1)</p>
<p>$user = $q-&gt;fetchOne();</p>
<p>次に``password``フィールドを遅延ロードし値を読み取るために追加のデータベースクエリを実行します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;password;</p>
<p>Doctrineはロードされたフィールドのカウントに基づいてプロキシの評価を行います。フィールドごとにどのフィールドがロードされるのかは評価しません。この理由は単純でパフォーマンスです。PHPの世界ではフィールドの遅延ロードはほとんど必要ないので、どのフィールドがロードされるのかチェックするこの種の変数を導入することは基本的な取得に不要なオーバーロードを持ち込むことになります。</p>
</div>
</div>
<div class="section" id="id40">
<h1>配列とオブジェクト<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h1>
<p><tt class="docutils literal"><span class="pre">Doctrine\_Record``と``Doctrine_Collection``は配列との連携を円滑にするメソッドを提供します:</span>
<span class="pre">``toArray()</span></tt>、<tt class="docutils literal"><span class="pre">fromArray()``と``synchronizeWithArray()</span></tt>。</p>
<div class="section" id="id41">
<h2>配列に<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a>toArray()``メソッドはレコードもしくはコレクションの配列表現です。これはオブジェクトが持つリレーションにもアクセスします。デバッグ目的でレコードを表示する必要がある場合オブジェクトの配列表現を取得して出力できます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... print_r($user-&gt;toArray());</p>
<p>配列にリレーションを格納したい場合、//true//の値を持つ引数``$deep``を渡す必要があります:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... print_r($user-&gt;toArray(true));</p>
</div>
<div class="section" id="id44">
<h2>配列から<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<p>配列の値がありレコードもしくはコレクションを満たすために使いたい場合、<a href="#id45"><span class="problematic" id="id46">``</span></a>fromArray()``メソッドはこの共通のタスクを簡略化します。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $data = array( &#8216;name&#8217; =&gt; &#8216;John&#8217;, &#8216;age&#8217; =&gt; &#8216;25&#8217;, &#8216;Emails&#8217; =&gt;
array( array(&#8216;address&#8217; =&gt; <a class="reference external" href="mailto:'john&#37;&#52;&#48;mail&#46;com">'john<span>&#64;</span>mail<span>&#46;</span>com</a>&#8216;), array(&#8216;address&#8217; =&gt;
<a class="reference external" href="mailto:'john&#37;&#52;&#48;work&#46;com">'john<span>&#64;</span>work<span>&#46;</span>com</a>&#8216;) &#8216;Groups&#8217; =&gt; array(1, 2, 3) );</p>
<p>$user = new User(); <tt class="code docutils literal"><span class="pre">user-&gt;fromArray(</span></tt>data); $user-&gt;save();</p>
<p>次のようにカスタムモデルのミューテータで``fromArray()``を使うことが可能です:</p>
<blockquote>
<div>// models/User.php</div></blockquote>
<p>class User extends Doctrine_Record { // ...</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">setEncryptedPassword</span><span class="p">(</span><span class="nv">$password</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_set</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="nb">md5</span><span class="p">(</span><span class="nv">$password</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a>fromArray()``を使う場合``encrypted_password``という名前の値を渡すことで``setEncryptedPassword()``メソッドを使うことができます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user-&gt;fromArray(array(&#8216;encrypted_password&#8217; =&gt; &#8216;changeme&#8217;));</p>
</div>
<div class="section" id="id49">
<h2>配列で同期する<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a>synchronizeWithArray()``によってレコードと配列を同期できます。モデルの配列表現がありフィールドを修正する場合、リレーションのフィールドを修正もしくはリレーションを削除もしくは作成します。この変更はレコードに適用されます。</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $q = Doctrine_Query::create() -&gt;select(&#8216;u.*, g.*&#8217;) -&gt;from(&#8216;User
u&#8217;) -&gt;leftJoin(&#8216;u.Groups g&#8217;) -&gt;where(&#8216;id = ?&#8217;, 1);</p>
<p>$user = $q-&gt;fetchOne();</p>
<p>これを配列に変換してプロパティの一部を修正します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $arrayUser = $user-&gt;toArray(true);</p>
<p>$arrayUser[&#8216;username&#8217;] = &#8216;New name&#8217;; $arrayUser[&#8216;Group&#8217;][0][&#8216;name&#8217;] =
&#8216;Renamed Group&#8217;; $arrayUser[&#8216;Group&#8217;][] = array(&#8216;name&#8217; =&gt; &#8216;New Group&#8217;);</p>
<p>レコードを読み取るために同じクエリを使いレコードと変数``$arrayUser``を同期します:</p>
<blockquote>
<div>// test.php</div></blockquote>
<p>// ... $user = Doctrine_Query::create() -&gt;select(&#8216;u.*, g.*&#8217;)
-&gt;from(&#8216;User u&#8217;) -&gt;leftJoin(&#8216;u.Groups g&#8217;) -&gt;where(&#8216;id = ?&#8217;, 1)
-&gt;fetchOne();</p>
<p><tt class="code docutils literal"><span class="pre">user-&gt;synchronizeWithArray(</span></tt>arrayUser); $user-&gt;save();</p>
<p>レコードをリンクするidの配列を指定することでリレーションをシンクロナイズすることもできます。</p>
<blockquote>
<div>$user-&gt;synchronizeWithArray(array(&#8216;Group&#8217; =&gt; array(1, 2, 3)));</div></blockquote>
<p>$user-&gt;save();</p>
<p>上記のコードは既存のグループを削除しユーザーをグループid
1、2、3にリンクします。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">リレーションを一緒にリンクするために内部では``Doctrine_Record::link()``と``Doctrine_Record::unlink()``が使われています。</p>
</div>
</div>
</div>
<div class="section" id="id52">
<h1>コンストラクタをオーバーライドする<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h1>
<p>ときどきオブジェクト作成時に同じオペレーションを行いたい場合があります。<a href="#id53"><span class="problematic" id="id54">``</span></a>Doctrine_Record::__construct()``メソッドをオーバーライドできませんが代わりの方法があります:</p>
<blockquote>
<div>class User extends Doctrine_Record { public function construct() {</div></blockquote>
<p>$this-&gt;username = &#8216;Test Name&#8217;; $this-&gt;doSomething(); }</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>}</p>
<p>唯一の欠点はコンストラクタにパラメータを渡す方法がないことです。</p>
</div>
<div class="section" id="id55">
<h1>まとめ<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h1>
<p>これでモデルのことがよくわかりました。これらを作り、ロードする方法を知っています。最も大事なことはモデルとカラムとリレーションを連携させる方法です。[doc
dql-doctrine-query-language :name]の章に移動して使い方を学びます。</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">テストスキーマを定義する</a></li>
<li><a class="reference internal" href="#id2">リレーションを扱う</a><ul>
<li><a class="reference internal" href="#id3">関連レコードを作成する</a></li>
<li><a class="reference internal" href="#id12">関連レコードを読み取る</a></li>
<li><a class="reference internal" href="#id13">関連レコードを更新する</a></li>
<li><a class="reference internal" href="#id14">関連レコードをクリアする</a></li>
<li><a class="reference internal" href="#id19">関連レコードを削除する</a></li>
<li><a class="reference internal" href="#id22">関連レコードに取り組む</a><ul>
<li><a class="reference internal" href="#id23">リレーションの存在をテストする</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id24">多対多のリレーション</a><ul>
<li><a class="reference internal" href="#id27">新しいレコードを作成する</a></li>
<li><a class="reference internal" href="#id30">リンクを削除する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id35">オブジェクトをフェッチする</a><ul>
<li><a class="reference internal" href="#id38">サンプルのクエリ</a></li>
<li><a class="reference internal" href="#id39">フィールドの遅延ロード</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id40">配列とオブジェクト</a><ul>
<li><a class="reference internal" href="#id41">配列に</a></li>
<li><a class="reference internal" href="#id44">配列から</a></li>
<li><a class="reference internal" href="#id49">配列で同期する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id52">コンストラクタをオーバーライドする</a></li>
<li><a class="reference internal" href="#id55">まとめ</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="defining-models.html"
                        title="previous chapter">カラム</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dql-doctrine-query-language.html"
                        title="next chapter">はじめに</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/ja/manual/working-with-models.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="dql-doctrine-query-language.html" title="はじめに"
             >next</a> |</li>
        <li class="right" >
          <a href="defining-models.html" title="カラム"
             >previous</a> |</li>
        <li><a href="../../index.html">Doctrine 1.2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Japanese Documentation</a> &raquo;</li>
          <li><a href="index.html" >Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jonathan Wage and Contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>